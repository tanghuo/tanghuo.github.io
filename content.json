{"meta":{"title":"Hexo","subtitle":null,"description":"目标资深","author":"汤","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"php手册杂","slug":"php手册杂","date":"2018-10-19T04:00:20.000Z","updated":"2018-10-19T04:00:44.458Z","comments":true,"path":"2018/10/19/php手册杂/","link":"","permalink":"http://yoursite.com/2018/10/19/php手册杂/","excerpt":"","text":"那运算符的结合方向决定了该如何运算。例如，”-“是左联的，那么 1 - 2 - 3 就等同于 (1 - 2) - 3 并且结果是 -4. 另外一方面，”=”是右联的，所以 $a = $b = $c 等同于 $a = ($b = $c)。","categories":[],"tags":[]},{"title":"TP相关","slug":"TP相关","date":"2018-10-18T09:44:35.000Z","updated":"2018-10-19T02:34:28.263Z","comments":true,"path":"2018/10/18/TP相关/","link":"","permalink":"http://yoursite.com/2018/10/18/TP相关/","excerpt":"","text":"Thinkphp 3.2.3 A()和R()方法都是对控制器类的实例化，R()方法比A()写法更简便，R()方法能直接返回类中方法返回的信息。R()方法里面封装了A()方法。 A(&apos;模块/控制器&apos;)； $a = A(&apos;Home/Index&apos;); echo $a-&gt;test(); R(&apos;模块/控制器/方法&apos;); echo R(&apos;Home/Index/test&apos;);","categories":[],"tags":[{"name":"TP","slug":"TP","permalink":"http://yoursite.com/tags/TP/"}]},{"title":"取模和取余的区别","slug":"取模和取余的区别","date":"2018-10-17T03:30:45.000Z","updated":"2018-10-22T13:57:15.502Z","comments":true,"path":"2018/10/17/取模和取余的区别/","link":"","permalink":"http://yoursite.com/2018/10/17/取模和取余的区别/","excerpt":"取模和取余的区别其实取模和取余在目标上是一致的，但是因为语言对取余和取模上定义的不同，导致得到的结果不同。 对取余和取模定义不同的语言中，两者的不同点只有一个 取余运算在计算商值向0方向舍弃小数位取模运算在计算商值向负无穷方向舍弃小数位同时，也可以这样理解： 取余，遵循尽可能让商大的原则取模，遵循尽可能让商小的原则从上面的区别可以总结出，取余（rem）和取模（mod）在被除数、除数同号时，结果是等同的，异号时会有区别，所以要特别注意异号的情况。 下面来看一些例子 取模","text":"取模和取余的区别其实取模和取余在目标上是一致的，但是因为语言对取余和取模上定义的不同，导致得到的结果不同。 对取余和取模定义不同的语言中，两者的不同点只有一个 取余运算在计算商值向0方向舍弃小数位取模运算在计算商值向负无穷方向舍弃小数位同时，也可以这样理解： 取余，遵循尽可能让商大的原则取模，遵循尽可能让商小的原则从上面的区别可以总结出，取余（rem）和取模（mod）在被除数、除数同号时，结果是等同的，异号时会有区别，所以要特别注意异号的情况。 下面来看一些例子 取模5 mod 3 = 2-5 mod 3 = 15 mod -3 = -1-5 mod -3 = -2取余 5 rem 3 = 2-5 rem 3 = -25 rem -3 = 2-5 rem -3 = -2经过测试，在C/C++, C#, JAVA, PHP这几门主流语言中，’%’运算符都是做取余运算，而在python中的’%’是做取模运算。 此外，余数在数学中的定义是始终大于等于0的，而对于某些编程语言的取余运算不是按照上面的定义来执行的，因此才会出现余数小于0的情况。 说了这么多，我们在使用取模（取余）运算时要注意的地方有一个，当除数和被除数出现异号的情况时，程序移植的时候要特别小心，因为不同语言对取模和取余的定义可能是不同的。","categories":[],"tags":[]},{"title":"redis相关2","slug":"redis相关2","date":"2018-10-16T02:31:28.000Z","updated":"2018-10-22T13:56:56.754Z","comments":true,"path":"2018/10/16/redis相关2/","link":"","permalink":"http://yoursite.com/2018/10/16/redis相关2/","excerpt":"订阅和发布 SUBSCRIBE PUBLISH PSUBSCRIBE UNSCRIBE PUNSUBSCRIBE PUBSUBPUBSUB subcommandPUBSUB CHANNELSPUBSUB NUMSUBPUBSUB NUMPAT 案例：消息队列","text":"订阅和发布 SUBSCRIBE PUBLISH PSUBSCRIBE UNSCRIBE PUNSUBSCRIBE PUBSUBPUBSUB subcommandPUBSUB CHANNELSPUBSUB NUMSUBPUBSUB NUMPAT 案例：消息队列 其他 ECHOECHO message PING QUIT SELECTSELECT index 【默认0号数据库】 AUTHAUTH password CONFIG GETCONFIG GET parameter CONFIG RESETSTAT CONFIG SETCONFIG SET parameter value CONFIG REWRITE CLIENT LIST CLIENT SETNAME CLIENT KILL DBSIZE FLUSHDB INFO MONITOR TIME SHOWDOWN redis 数据持久化HYPERLOGLOG PFADDPFADD key element 【element。。】PFCOUNTPFCOUNT key 【key。。】PFMERGEPRMERGE destkey key 【key。。】|GEO 地理位置存储 GETADDGEOADD key longitudu latitude member 【。。。】 GETPOSGETPOS key member 【member。。】 GETDISTGETDIST key member member2 【unit】 GEORADIUS…..方圆多少里内的用户？ GEORADIUSBYMEMBER GEOHASH 事务 MULTI开启事务 EXEC执行事务块内的命令 DISCARD取消事务，放弃执行命令 WATCHWATCH key 【key。。】监控，如果key改变，则事务被打断 UNWATCH*","categories":[],"tags":[]},{"title":"redis相关","slug":"redis相关","date":"2018-10-15T06:01:28.000Z","updated":"2018-10-22T13:56:54.239Z","comments":true,"path":"2018/10/15/redis相关/","link":"","permalink":"http://yoursite.com/2018/10/15/redis相关/","excerpt":"redis相关key key基本操作 keykey pattern用法:?/*/[ae]/[^ae]/[a-c] EXISTSEXISTS key [key …]key是否存在返回值 1 或者 0 SACNSCAN cursor[MATCH pattern] [COUNT count]SCAN命令每次被调用后，都会向用户返回一个新的游标，用户在下次迭代时需要使用这个新游标作为SACN命令的游标参数，以此延续之前的迭代过程返回值：完整遍历的数据 RANDOMKEYRANDOMKEY从数据库随即返回一个键名返回值：键名 TPYETYPE KEY查询key的类型返回值：srting，hash，list，zset等 OBJECTOBJECT sucomand [arguments[arguments…]]从内部查看给定key的redis对象OBJECT REFCOUNT KEYOBJECT ENCODING KEYOBJECT IDLETIME KEY返回值：REFCOUNT和IDLETIME返回数字，ENCODING返回相应的编码类型 RENAMERENAME KEY NEWKEY改名 RENAAMENXRENAMENX KEY NEWKEY TOUCHTOUCH KEY修改key的最后访问时间为当前时间返回值：返回设置成功的key的数量 DELDEL KEY UNLINKUNLINK KEY [KEY..]非阻塞删除指定key","text":"redis相关key key基本操作 keykey pattern用法:?/*/[ae]/[^ae]/[a-c] EXISTSEXISTS key [key …]key是否存在返回值 1 或者 0 SACNSCAN cursor[MATCH pattern] [COUNT count]SCAN命令每次被调用后，都会向用户返回一个新的游标，用户在下次迭代时需要使用这个新游标作为SACN命令的游标参数，以此延续之前的迭代过程返回值：完整遍历的数据 RANDOMKEYRANDOMKEY从数据库随即返回一个键名返回值：键名 TPYETYPE KEY查询key的类型返回值：srting，hash，list，zset等 OBJECTOBJECT sucomand [arguments[arguments…]]从内部查看给定key的redis对象OBJECT REFCOUNT KEYOBJECT ENCODING KEYOBJECT IDLETIME KEY返回值：REFCOUNT和IDLETIME返回数字，ENCODING返回相应的编码类型 RENAMERENAME KEY NEWKEY改名 RENAAMENXRENAMENX KEY NEWKEY TOUCHTOUCH KEY修改key的最后访问时间为当前时间返回值：返回设置成功的key的数量 DELDEL KEY UNLINKUNLINK KEY [KEY..]非阻塞删除指定key key的过期设定 EXPIREEXPIRE key seconds为key设定生存时间，过期自动删除返回值：成功为1，失败为0； EXPIREATEXPIREAT key timestamp PEXPIRE时间为毫秒 PEXPIREAT TTLTTL key以秒为单位，返回给定key的生存时间 PTTL毫秒单位 PERSISTPERSIST key移除生存时间 DUMPDUMP key序列化key，并返回序列化后的值，不包括生存信息 RESTIRERESTORE key ttl serialized-value[REPLACE]反序列化给定key的序列化值，并将它和给定key关联，参数ttl以浩渺设定生存时间，若0，则不设置。 SORT…. 单个实例内多库间的数据迁移操作 MOVEMOVE key db 多个实例内的数据迁移操作 MIGRATEMIGRATE host port key destination-db timeout[COPY ][REPLACE]返回值：ok 字符串 string 应用场景高速缓存html片段或者页面高速缓存关系型数据库查询的数据结果高速缓存会话控制数据分布式锁防止重复提交存储设置固定格式的字符串序列（例如：时间序列）统计网站访问者数量每天注册用户数限制API在某一时段的访问次数用户签到统计活跃用户用户在线状态 基本命令 设置 SETSET key value [EX][PX][NX|XX]覆盖，SET设置之后，之前的生存时间会被丢弃返回 OK 和 nilnx：如果key不存在则建立 xx：如果key存在则修改其值 MSETMSET key value【key value。。。】同时设置多个key，覆盖原子性， 会同时设置或者失败 SETEXSETEX key seconds value原子性成功ok PSETEX SETNXSETNX key value我如果key不存在，设定value MSETNX SETRABGESETRANGE key offset value如果键不存在，就设置一个新的，并且补充offset个null，在加入value。换句话说，值为offet个null+value最大值为2的29次方-1 APPENDAPPEND key value如果key存在，追加value内容如果不存在 ，会创建一个新的key，并设置其值为空字符串，然后追加value内容返回追加后的字符串长度查询 GETGET key如果不存在，返回nil如果不是string，返回错误 MGETMGET key 【key。。。】列出所有键的纸，绝不会执行失败，失败或string返回nil GETRANGEGETRANGE key start end可以是负数，-1代表最后一个字符 STRLENSTRLEN key如果不是字符串，返回错误 GETSETGETSET key value原子的给一个key设置value，并给返回旧的值 字符串的设置和查询相应场景： 案例一 高速缓存（HTML/DATA/SESSION） 案例二：分布式锁 案例三：防止重复提交 案例四：存储设置固定格式的字符串序列 键的计数 INCRINCR key将key中存储的值增加一，如果key不存在，那么key会被初始化为0，然后再INCR。本操作的值限制在64位有符号数字表示之间，key的值必须是整型 INCRBYINCRBY key increment将key存储的值增加increment INCRBYFLOATINCRBYFLOAT key increment加上浮点增量可以使用科学计数法 DECRDECR key减法 DECRBY 案例： 每天访问的人数 每天注册的人数 限制API在某一时段的访问次数 单号生成 错误拦截 字符串的二进制操作 SETBITSETBIT key offset value对key所存储的字符串值，设置或清除指定偏移量上的位，位的设置或者清除取决于value参数，可以是0也可以是1。字符串会进行伸展以确保它可以将value保存在指定的偏移量上。当字符串值进行伸展时，空白位置以0填充。offset参数必须大于或等于0，小于2的32次方。返回值：当key不存在时，自动生成一个新的字符串指定偏移量原来存储的位 GETBITGETBIT key offset BITCOUNTBITCOUNT key 【start】 【end】计算给定字符串中，被设置为1的比特位的数量。1为8位 BITOPBITOP operation destkey key 【key 。。】对一个或者多个保存二进制的字符串key进行位元操作，并将结果保存在destkey上operation and or not xor 中的一种注意：较短字段缺少的部分会被视为0 BITPOSBITPOS key bit 【start】 【end】返回字符串中第一个被设置为1或者0的bit没找到为=1 项目案例：用户签到统计活跃用户用户在线状态 哈希表数据类型 HSETHSET key filed value将哈希表key中的域field的值设置为value。如果key不存在，将会新建哈希表并进行HSET操作 HSETNXHSETNX key field value将哈希表key中的域field的值设置为value，当且仅当filed不存在。 HMSETHMSET key field value [field value….] HINCRBYHINCRBY key field value HINCRBYFLOAT HGETHGET key field HGETALLHGETALL key返回哈希表key中所有的域和值返回值里面，紧跟在每个域名后的是域的值，所以返回值的长度是哈希表的两倍 HMGETHMGET key filed 【field。。。】 HKEYSHKEYS key获取哈希表中的field HVALSHVALS key HEXISTSHEXIST kye field返回哈希表key中的域field的数量 HLENHLEN key HSTRLENHSTRLEN key field返回哈希表key中，给定域field相关联的值的字符串长度 HDELHDEL key field 【field 。。】删除哈希表key中的一个或多个指定域 案例： 会员信息 用户购物车 List数据类型 应用场景 ： 粉丝列表 时间轴（Timeline） 最新文章 消息队列 LPUSHLPUSH key value【value】将一个或者多个value 插入key的表头多个值的情况下，由左到右原子性假如key不存在，则创建空列表并且LPUSH LPUSHXLPUSHX key value列表要已经存在，不存在不插入 LINSERTLINSERT key BEFORE|AFTER pivot value将值value插入到列表key当中，位于值pivot的前后keyA或pivot不存在，不插入 LSETLSET key index value列表不存在或者key不存在，不执行 RPUSH RPUSHX 查询 LINDEXLINDEX key index返回列表key中，下标为index的元素，0为第一个元素，-1为最后一个元素 LLENLLEN key返回列表key的长度 LRANGELRANGE key start end返回列表key中指定区间的元素 ，-1为列表最后 删除： LPOPLPOP key移除并返回列表key的头元素 LREMLREM key count value根据参数count的值，移除列表中参数value相等的元素count&gt;0，从表头到表尾搜索，移除于value相等的值。count&lt;0,从表尾向表头搜索，移除与count相等的元素。count=0，移除标中所有和count相等的元素 LTRIMLTRIM key start end对一个列表进行修剪，就是说，让列表之保留指定区间内的元素，不在指定区间之内的元素都将被删除 RPOP RPOPLPUSHRPOPLPUSH source destination在一个原子时间内，执行两个动作：将列表source中的尾元素弹出，并返回给客户端。将source弹出的元素插入到destination，作为destination列表的头元素返回值：被弹出的元素||| | BLPOPBLPOP key [key …] timeoutBLPOP是列表的阻塞式弹出原语，LPOP命令的阻塞版本，当前给定列表内没有任何元素可供弹出的时候，连接将被BLPOP命令阻塞，直到等待超时或发现可弹出元素为止返回弹出值 BRPOP BRPOPLPUSH 案例：粉丝列表最新文章消息队列 集合set是string类型的无序集合集合成员唯一，不能出现重复的数据场景：共同好友好友推荐 SADDSADD keymember [member…]将一个或者多个member假如到集合key中，已经存在于集合中的member元素将会忽略如果集合不存在，将会创建返回新假如的元素的数量，忽视被忽略的元素 SCARDSCARD key返回集合key的基数 （集合中元素的数量） SMEMBERSSMEMBERS key返回集合中的元素 SISMEMBERSISMEMBER key member检查一个元素是否在集合中返回值1和0 SRANDMEMBERSRANDMEMBERE key 【count】count默认为1，返回集合中随即的一个元素 SSCANSSCAN key cursor 【match pattern】 【COUNT count】用于迭代集合键中的元素返回集合中的元素 SDIFFSDIFF key [key…]返回一个集合的全部成员，该集合是所有给定集合之间的差集 SDIFFSTORESDIFFSTORE destination key [key…]类似SDIFF，它将结果保存到destination集合，而不是简单的返回结果集如果destination已经存在，则将其覆盖 SINTERSINTER key 【key】返回一个集合的全部成员，该集合是所有给定集合的交集不存在的key视为空集合 SINTERSTORE SUNIONSUNION key 【key。。】并集 SUNIONSTORE SPOPSPOP key移除并返回集合中的一个随机元素 SREMSREM key member【member】移除集合key中的一个member元素 SMOVESMOVE source destination member将member元素从source 移动到destination集合原子性 案例：共同好友好友推荐 有序集合类型sortsetstring类型的集合，不允许有重复成员不同的是每个元素都会关联一个double类型的分数redis正是通过分数来为集合中的成员进行从小到大的排序有序集合的成员是唯一的，但分数却可以重复 案例：排行榜 ZADDZADD key key score member【score member。。。】将一个或多个member和score加入有序集合key中如果已有，以member为基准更新score重新插入？ ZINCRBYZINCRBY key increment member为有序集合key的成员member的score的值加上increment当key不存在时，或member不存在时，相当于ZADD ZCARDZCARD key返回有序集合key的基数（有序集合的元素数量） ZCOUNTZOUNT key min max返回有序集合key中，score在min和max之间的基数。 ZRANGEZRANGE key start end 【WITHSCORE】返回有序集合中，指定区间的集合 ZRANGEBYSCOREZRANGE key start end 【WITHSCORE】 【LIMIT offset count】 ZRANKZRANK key member返回有序集合key中成员member的排名，按照score的从小到大排名最小为0 ZREVRABGE ZREVRABGEBYSCORE ZREVRANK ZCOREZSCORE key member返回有序key中，成员啊member的score值返回member成员的score值，以字符串形式表示 ZCAN key cursor 。。。。。。。。。 ZRANGEBYLEX。。。。。score相同，字典序排序 ZLEXCOUNTZLEXCOUNT key min max……| ZUNIONSTOREZUNIONSTORE DESTINATION MUMKEYS key [key..]….. 【WEIGHT】 SUM|MIN|MAX计算给定一个或者多个有序集合的并集，其中给定key的数量必须以mumber参数给定。。。。默认情况下，结果集中某个成员的score的值是所有给定集下该成员score之和 ZINTERSTORE ZREM key member 【member】 ZREMRANGEBYRANKZRENRANGEBYRANK key start end ZREMRANGEBYSCORE ZRENRABGEBYLEX*","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}]},{"title":"mysql的分表","slug":"mysql的分表","date":"2018-10-13T18:14:38.000Z","updated":"2018-10-13T18:15:52.567Z","comments":true,"path":"2018/10/14/mysql的分表/","link":"","permalink":"http://yoursite.com/2018/10/14/mysql的分表/","excerpt":"","text":"mysql分布式分表思路 根据具体的业务处理分表 不要盲目分表","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"简单框架设计","slug":"简单框架设计","date":"2018-10-13T15:45:11.000Z","updated":"2018-10-22T13:57:39.847Z","comments":true,"path":"2018/10/13/简单框架设计/","link":"","permalink":"http://yoursite.com/2018/10/13/简单框架设计/","excerpt":"","text":"简单框架设计 目录结构 admin入口文件 123456789101112131415161718192021222324252627282930&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;);//设置框架编码 define(&apos;APP_PATH&apos;,__DIR__.&apos;/&apos;);//设置时间区域 define(&quot;Lib&quot;,&quot;./myphp/&quot;);//定义项目路径常量 define(&quot;Resource&quot;,APP_PATH.&apos;Resource&apos;);//定义框架目录常量 ini_set(&quot;display_errors&quot;,1);//定义项目资源目录常量 ini_set(&quot;data.timezone&quot;,&quot;Asia/Shanghai&quot;);//是否抛出错误``` #### display_errors介绍 display_errors介绍：错误回显，一般常用语开发模式，但是很多应用在正式环境中也忘记了关闭此选项。错误回显可以暴露出非常多的敏感信息，为攻击者下一步攻击提供便利。推荐关闭此选项。 display_errors = On 开启状态下，若出现错误，则报错，出现错误提示 dispaly_errors = Off 关闭状态下，若出现错误，则提示：服务器错误。但是不会出现错误提示 &lt;!--more --&gt;#### 自动加载类的介绍 在编写面向对象（OOP） 程序时，很多开发者为每个类新建一个 PHP 文件。 这会带来一个烦恼：每个脚本的开头，都需要包含（include）一个长长的列表（每个类都有个文件）。在 PHP 5 中，已经不再需要这了。 spl_autoload_register() 函数可以注册任意数量的自动加载器，当使用尚未被定义的类（class）和接口（interface）时自动去加载。通过注册自动加载器，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。 #### spl_autoload_register 这个是框架的关键，它能够自动加载未定义的类，接下来通过将类分布在各文档，用路径寻找到，依次前后拼接，形成一个完整的文件,admin获得index。#### 临时 set_error_handler(&quot;customError&quot;) 不仅可以接受函数，还可以接受 类的方法（公开的静态方法 及 公开的非静态方法 都可以），但需要以 数组形式 传递，数组的第一值为“类名”，第二个参数为“方法名” 简单示例 框架入口&lt;?php//框架的运行方法class Myphp{ public function run() { spl_autoload_register(array($this,’load’)); // set_error_handler(array($this,’AppError’)); // set_exception_handler(array($this,’AppException’)); //上面两个注释是错误log，暂不开启 $temp = explode(&quot;/&quot;, $_SERVER[&apos;REDIRECT_URL&apos;]); var_dump($temp); $temp = array_map(&apos;ucfirst&apos;, $temp); $class = $temp[3]; $class = $class . &apos;Action&apos;; $func = $temp[4]; if ($temp[3] == &apos;&apos;) { $class = &apos;IndexAction&apos;; $func = &apos;Index&apos;; } if ($temp[4] == &apos;&apos;) { $func = &apos;Index&apos;; } $index = new $class(); $index -&gt; call($class, $func); } private function load($className) { if ($className == &quot;Action&quot;) { require(APP_PATH.Lib.&apos;Core/&apos;.$className.&apos;.class.php&apos;); } if ($className == &quot;ActionMiddleware&quot;) { require(APP_PATH.&apos;/App/Util/&apos;.$className.&apos;.class.php&apos;); } if (strpos($className, &quot;Action&quot;) != 0) { require(APP_PATH.&apos;App/Action/&apos;.$className.&apos;.class.php&apos;); } } public function AppError($errno, $errstr, $errfile, $errline) { $error = &apos;Time【&apos;.date(&apos;Y-m-d H:i:s&apos;).&apos;】&apos;; $error .= &apos;errno:&apos;.$errno.&quot;\\t\\t&quot;; $error .= &apos;errorInfo:&apos;.$errstr.&apos;&lt;br&gt;&apos;; $error .= &apos;filePath&apos;.$errfile.&apos;&lt;br&gt;&apos;; $error .= &apos;line:&apos;.$errline.&apos;&apos;.&quot;\\t\\t&quot;; $error .= &apos;quest:&apos;.$_SERVER[&apos;HTTP_HOST&apos;].$_SERVER[&apos;REQUEST_URI&apos;].PHP_EOL; file_put_contents(&apos;Log/&apos;.date(&apos;Y-m-d&apos;).&apos;_error.log&apos;, $error, FILE_APPEND); if (APP_DEBUG==true) { die($error); } exit; } public function AppException($e) { file_put_contents(&apos;Log/&apos;.date(&apos;Y-m-d&apos;).&apos;_error.log&apos;, $e-&gt;__toString().PHP_EOL, FILE_APPEND); if (APP_DEBUG==true) { die($e-&gt;__toString()); } exit; } } //项目入口 &lt;?php header(&quot;Content-type:text/html;charset=utf-8&quot;); //设置框架编码 ini_set(&quot;date.timezone&quot;, &quot;Asia/Shanghai&quot;);//设置时间区域 define(&apos;APP_PATH&apos;, __DIR__.&apos;/&apos;);//定义项目路径常量 define(&apos;Lib&apos;, &apos;../myphp/&apos;);//定义框架目录常量 define(&apos;Resource&apos;, APP_PATH.&apos;Resource&apos;);//定义项目资源目录常量 define(&apos;APP_DEBUG&apos;, true); ini_set(&quot;display_errors&quot;, 1);//是否抛出错误 // echo __DIR__; require_once(Lib.&quot;myphp.php&quot;); $myphp = new myphp(); $myphp -&gt; run(); //核心的action类 &lt;?php class Action{ public $assign_arr; public function Before() { echo “im a before”; echo ““; } public function After() { echo “im a after”; echo ““; } public function call($class, $func) { $this -&gt; Before(); $tmpMiddle = new $class(); $tmpMiddle -&gt; $func(); $this -&gt; After(); } public function assign($str, $val) { $this -&gt; assign_arr[$str] = $val; } public function display($view) { $temp = file_get_contents(APP_PATH.’App/View/‘.$view.’.html’); foreach ($this-&gt;assign_arr as $key =&gt; $value) { $patten = ‘/{!’.$key.’}/i’; $temp = preg_replace($patten, $value, $temp); } $tem_path = APP_PATH.’App/Tep/‘.md5($view).’.html’; file_put_contents($tem_path, $temp); echo $temp; }} ` 框架的各部分，路由，模型，控制器，模板，日志在思路上是统一的。","categories":[],"tags":[]},{"title":"简单的虚拟主机设置","slug":"简单的虚拟主机设置","date":"2018-10-13T15:20:21.000Z","updated":"2018-10-13T15:25:01.008Z","comments":true,"path":"2018/10/13/简单的虚拟主机设置/","link":"","permalink":"http://yoursite.com/2018/10/13/简单的虚拟主机设置/","excerpt":"","text":"简单的虚拟主机设置 找到apache的httpd.conf文件,修改 12345# Virtual hosts#Include conf/extra/httpd-vhosts.conf把它改成下面这样：# Virtual hostsInclude conf/extra/httpd-vhosts.conf 修改hots文件,例如127.0.0.1 www.myphp.com 在httpd-vhosts.conf文件修改 12345&lt;VirtualHost *:80&gt; DocumentRoot &quot;D:/AppServ/www/myphp/admin&quot; ServerName www.myphp.com DirectoryIndex index.php index.html&lt;/VirtualHost&gt; 日后在补充……","categories":[],"tags":[]},{"title":"加密登录","slug":"加密登录","date":"2018-10-13T14:12:24.000Z","updated":"2018-10-22T13:57:09.391Z","comments":true,"path":"2018/10/13/加密登录/","link":"","permalink":"http://yoursite.com/2018/10/13/加密登录/","excerpt":"加密登录 介绍 Ras算法，非对称加密。公钥秘钥：公钥加密，私钥解密，私钥加密，公钥解密。 需要安装openssl模块 php相关函数 openssl_pkey_get_public //检查公钥是否可用 openssl_public_encrypt //公钥加密 openssl_pkey_get_private //检查私钥是否可用 openssl_private_encrypt //私钥加密 js相关函数 需要安装相关类库 publicKey =””; //公钥 var hsebcrtot = new JSEncrypt(); jsencrypt.setPublicKey(publicKey); return jsencrypt.encrypt(str);","text":"加密登录 介绍 Ras算法，非对称加密。公钥秘钥：公钥加密，私钥解密，私钥加密，公钥解密。 需要安装openssl模块 php相关函数 openssl_pkey_get_public //检查公钥是否可用 openssl_public_encrypt //公钥加密 openssl_pkey_get_private //检查私钥是否可用 openssl_private_encrypt //私钥加密 js相关函数 需要安装相关类库 publicKey =””; //公钥 var hsebcrtot = new JSEncrypt(); jsencrypt.setPublicKey(publicKey); return jsencrypt.encrypt(str); php示例 12345678910111213141516171819202122232425function RSA_opensll($date,$type=&quot;encode&quot;)&#123; if(!empty($data))&#123; die(&quot;加解密输入为空&quot;); &#125; if($type == &quot;encode&quot;)&#123; $key = openssl_pkey_get_public(RSA_public);//RSA_public为外部定义的 if(!$key)&#123; die(&quot;不合规的公钥&quot;); &#125; openssl_public_encrypt($data,$crypted,$key); $crypted = base64_encode($crypted); //没有此步，则为乱码 return $crypted; &#125; if($type == &quot;decode&quot;)&#123; $key = openssl_pkey_get_private(RSA_private);//RSA_private为外部定义的 if(!$key)&#123; die(&quot;不合规的私钥&quot;); &#125; $data = base64_decode($data); openssl_private_encrypt($data,$crypted,$key); return $crypted; &#125;&#125;","categories":[],"tags":[]},{"title":"Mongodb相关","slug":"Mongodb相关","date":"2018-10-13T09:34:42.000Z","updated":"2018-10-22T13:56:25.620Z","comments":true,"path":"2018/10/13/Mongodb相关/","link":"","permalink":"http://yoursite.com/2018/10/13/Mongodb相关/","excerpt":"Mongodb 开启启动echo &#39;/usr/local/mongodb/bin/mongod --dbpath=/usr/local/mongodb/data&#39; &gt;&gt;/etc/rc.local 启动mongodb/usr/local/mongodb/bin/mongodb --dbpath=/usr/local/mogodb/data --fork --logpath=/usr/local/mongodb/dblogs","text":"Mongodb 开启启动echo &#39;/usr/local/mongodb/bin/mongod --dbpath=/usr/local/mongodb/data&#39; &gt;&gt;/etc/rc.local 启动mongodb/usr/local/mongodb/bin/mongodb --dbpath=/usr/local/mogodb/data --fork --logpath=/usr/local/mongodb/dblogs – dbpath执行逐句酷存放路径（默认是data/db）– fork是以Daemon（进程）方式运行注意:如果指定–fork参数，必须指定 –logpath日志文件路径注意：如果不加–fork参数，则需要再开启一个Mongodb启动窗口 –dbpath 指定数据库的目录–port 指定数据库的端口,默认是27017–bind_ip 绑定IP–directoryperdb为每个db创建一个独立子目录–logpath指定日志存放目录–logappend指定日志生成方式(追加/覆盖)–pidfilepath 指定进程文件路径,如果不指定,将不产生进程文件–keyFile 集群模式的关键标识–journal 启用日志–nssize 指定.ns 文件的大小，单位MB，默认是16M，最大是 2GB–maxConns 最大的并发连接数–notablescan 不允许进行表扫描–noprealloc 关闭数据文件的预分配功能–fork 以后台Daemon形式运行服务 进入客户端操作/usr/local/mongodb/bin/mongo 退出shell控制台ctrl+c或exit 停止 MongoDB服务器如果处理连接状态，那颗直接可以通过在admin库中发送db.shutdownServer()指令去停止注意：不要用kill - 9 PID来杀死mongodb进程，这样会导致Mongodb的数据损坏，用kill -2来杀死进程。 Mongodb体系结构mysql分为database，table和rows。mongodb分为database，collection和document。mongodb的机核对应数据库的表，但集合没有行列和关系的概念，一个文档就是一条记录，这体现了模式自由的特点。 数据存储结构mysql:它的每个数据库存放在一个和数据库同名的文件夹中，mysql如果使用MYISAM存储引擎，数据库文件类型就包裹.frm,.MDY,.MYImongodb:它的默认数据目录是/data/db,它负责存储所有的mongodb的数据文件。在mongodb内部，每个数据库都包裹一个.ns文件和一些数据文件。随着数据量的增加，数据文件越来越多。所以如果系统中有一个叫做mydb的数库，那么构成mydb这个数据库的文件就由mydb.ns,mydb.0,mydb.1等等组成。 mongodb的数据类型 mongodb的文档使用bson（Binary JSON）来组织数据，BSON类似于JSON，JSON这是一种简单的镖师数据的方式，只包含了六种数据类型。（null,布尔，数字，字符串，数组和对象），不能玩去哪满足复杂业务的需求，因此，BSON还嫩提供日期，32位数字，64位数组等类型。 nullnull用于表示空值或者不存在的字段{‘one’:’null’} 布尔类型[‘one’:true] 32位整数mongodb的控制台使用JS引擎进行输入，而JS仅支持64位浮点数，所以32位整数将会被自动转义 64位整数64位整数与32位整数一样，在MongoDB控制台使用时，会转义成64位浮点数 64位浮点数mongdb控制台数字的默认类型{‘noe’:2.2} 字符串UFT-8字符串都可以表示Wie字符串类型的数字{‘one’:’Hello World’} 符号在mongdb控制台不支持这种类型，将会自动转义为字符串 objectId类型对象id是文档中唯一的12位的ID0|1|2|3|4|5|6|7|8|9|10|11时间戳 |机器 | PID | 计数器如：ObjectId(“4eae239f63520362e051e7fd”) 时间使用时候要加上new{‘one’:new Data()} 正则表达式文档键值可以包含正则表达式，其正则表达式采用JS语法来表示。如：{“one”:/ho/i} 代码文档中可以包含JS代码如：{“one”:function(){/…………./}} 数组文档中键值可以表示为数组，在数组内还可以嵌套数组；如：{“x”:[“a”,”b”,[“c”,”d”]]} 内嵌文档文档可以包含别的文档，也可以作为值嵌入到父文档中。如：{“x”:{“name”:”Tom”,”age”:20}} 常用命令 如果查看当前连接在哪个数据库下，直接输入db查看用户列表 db.system.users.find() ;查看所有用户show users;查看所有数据库 show dbs;查看所有集合 show collections;删除当前的数据库 db.dropDatabase();删除collection db.集合名.drop();想知道mongodb支持哪些命令，可以直接输入help；想只要当前数据库支持哪些方法，db.help();想知道当前集合支持的方法: db.user.helo();user为集合名 由于Mongodb不是关系型数据库文件，实际上，它并不存在传统关系型数据库中的所谓“数据库”的概念，当你第一次新增数据时，MongoDB就会以collection集合的形式进行保存和新建，而不需要你提前去建立 id key存储在MongoDB 集合中的每个文档(document)都有一个默认的主键_id，它必须是唯一的，这个主键名称是固定的，它可以是MongoDB 支持的任何数据类型，默认是ObjectId。在关系数据库的设计中，主键大多是数值型的，比如常用的int，并且更通常的是主键的取值由数据库自增获得，反观 MongoDB，它在设计之初就定位于分布式存储系统，所以它原生的不支持自增主键 mongodb插入原理MongoDB插入原理：使用驱动程序进行插入的时候，会将数据转换成BSON格式。数据库会解析BSON，并检验是否含有’_id’键，因为“_id”键在插入到数据库时MongoDB会自动生成。而且每次插入文档不能超过4M，MongoDB1.8版本以上的支持16M批量插入：如果要插入多个文档，使用批量插入会快一些，批量插入能传递一个由文档构成的数组给数据库一次发送是单个TCP请求，如果插入数百，数千个文档会有明显的速度提升，用批量插入数据的话，数据库就不会一次又一次的处理接受的请求注意：Insert和Save的区别是：用Insert插入,在集合中已经存在相同的“_id”值,执行插入操作回报异常。用Save插入如果集合中没有相同的“_id”值就执行插入操作，有的话就执行覆盖掉原来的值，相当于修改操作。在新建一个集合或者一个数据库时，MongoDb不会在马上生成。而是在你添加了第一个数据后才会创建 remove 删除数据db.collname.remove({条件})（不写条件删除所有记录）Remove比较简单，只有一个参数，就是限定删除的文档的条件，如果不指定，则删除集合内所有的文档，但集合本身并不删除，索引页会保留，删除数据是永久性，不能撤销，不能恢复注意：删除的条件最好是以id键为标准，也可以在文档中自己指定id,如（uid，gid，sid）都可以作为删除条件 修改数据 updata• MongoDB更新有两个命令：update() Save()u update()命令• db.collection.update(criteria,objNew,upsert,multi)ü criteria : update的查询条件,类似sql的update查询内where后面的条件。ü objNew :update的对象和一些更新的操作符如$set、$inc也可以理解为sql的update查询内set后面的赋值。ü upsert :如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。ü multi : mongodb默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 修改器 $inc 增加和减少用法:{$inc:{field:value}}对一个数字字段field增加value。例:注意：$inc指定的字段必须是数字类型的。 1234567891011121314151617181920212223242526272829303132333435363738394041db.games.insert(&#123;&quot;_id&quot;:1,&quot;game&quot;:&quot;pinball&quot;,&quot;name&quot;:“lisi&quot;&#125;) db.games.update(&#123;“game”:“pinball”,“name”:“lisi”&#125;,&#123;$inc:&#123;“score”:50&#125;&#125;) db.games.update(&#123;“game”:“pinball”,“name”:“lisi”&#125;,&#123;$inc:&#123;“score”:100&#125;&#125;) db.games.update(&#123;“game”:“pinball”,“name”:“lisi”&#125;,&#123;$inc:&#123;“score”:-80&#125;&#125;) ``` 2. $set,$unset 用法：&#123; $set : &#123; field : value &#125; &#125; 就是相当于sql的set field = value，全部数据类型都支持$set,如果修 改的字段不存在，则自动创建。 ``` db.book.insert(&#123;&quot;_id&quot;:1,&quot;name&quot;:&quot;caida&quot;,&quot;age&quot;:25&#125;); db.book.update(&#123;&quot;name&quot;:&quot;caida&quot;&#125;,&#123;$set:&#123;&quot;book&quot;:“linux&quot;&#125;&#125;);db.book.update(&#123;&quot;name&quot;:&quot;caida&quot;&#125;,&#123;$set:&#123;&quot;book&quot;:“mysql&quot;&#125;&#125;);db.book.update(&#123;&quot;name&quot;:&quot;caida&quot;&#125;,&#123;$unset:&#123;&quot;book&quot;:“mysql&quot;&#125;&#125;);``` 3. $Push 用法：&#123; $push : &#123; field : value &#125; &#125; 把value在数组末尾追加到field里面去，field一定要是数组 类型才行，如果field不存在，会新增一个数组类型加进去 ``` db.array.insert(&#123;&quot;_id&quot;:1,&quot;arr&quot;:[&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;]&#125;); db.array.update(&#123;&quot;_id&quot;:1&#125;,&#123;$push:&#123;&quot;arr&quot;:&quot;ddd&quot;&#125;&#125;); db.array.update(&#123;&quot;_id&quot;:1&#125;,&#123;$push:&#123;&quot;arr1&quot;:&quot;eee&quot;&#125;&#125;);``` 4. $assToSet 用法：&#123; $addToSet : &#123; field : value &#125; &#125; 增加一个值到数组内，且只有当这个值不存在时才增加 ``` db.array.find(&#123;&quot;_id&quot;:2&#125;) &#123; &quot;_id&quot; : 2, &quot;arr&quot; : [ &quot;aa&quot;, &quot;dd&quot; ] &#125; &gt; db.array.update(&#123;&quot;_id&quot;:2&#125;,&#123;$addToSet:&#123;&quot;arr&quot;:&quot;cc&quot;&#125;&#125;); &gt; db.array.find(&#123;&quot;_id&quot;:2&#125;) &#123; &quot;_id&quot; : 2, &quot;arr&quot; : [ &quot;aa&quot;, &quot;dd&quot;, &quot;cc&quot; ] &#125; &gt; db.array.update(&#123;&quot;_id&quot;:2&#125;,&#123;$addToSet:&#123;&quot;arr&quot;:&quot;cc&quot;&#125;&#125;); &gt; db.array.find(&#123;&quot;_id&quot;:2&#125;) &#123; &quot;_id&quot; : 2, &quot;arr&quot; : [ &quot;aa&quot;, &quot;dd&quot;, &quot;cc&quot; ] &#125; ``` 5. $pop 用法： 删除最后一个值：&#123; $pop : &#123; field : 1 &#125; &#125; 删除第一个值： &#123; $pop : &#123; field : -1 &#125; &#125; db.array.find({“_id”:2}){ “_id” : 2, “arr” : [ “aa”, “bb”, “cc”, “dd”, “ee”, “ff” ] }db.array.update({“_id”:2},{$pop:{“arr”:-1}})db.array.find({“_id”:2}){ “_id” : 2, “arr” : [ “bb”, “cc”, “dd”, “ee”, “ff” ] }db.array.update({“_id”:2},{$pop:{“arr”:1}})db.array.find({“_id”:2}){ “_id” : 2, “arr” : [ “bb”, “cc”, “dd”, “ee” ] }1234567891011126. $pull $pullAll $pull: &#123; field : value &#125; &#125; 从数组field内删除一个等于value的值 $pullAll ：&#123; $pullAll : &#123; field : value_array &#125; &#125; 从数组field内删除多个等于value的值 ``` &gt; db.array.update(&#123;&quot;_id&quot;:2&#125;,&#123;$pull:&#123;&quot;arr&quot;:&quot;bb&quot;&#125;&#125;)&gt; db.array.update(&#123;&quot;_id&quot;:2&#125;,&#123;$pullAll:&#123;&quot;arr&quot;:[&quot;aa&quot;,&quot;bb&quot;]&#125;&#125;)``` 7. $rename功能: 重命名指定的字段名称，从 1.7.2 版本后开始支持 例子：给arr字段重命名为 agg db.array.update({“_id”:2},{$rename:{“arr”:”agg”}})123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051瞬间完成 我们以上讨论的（增 删 改）都是瞬间完成的，他们都不需要 等待数据库的响应，只受客户端发送的速度和网速的限制。 这个特点的优点就是速度快 高级查询 ==== 面向文档的 NoSQL 数据库主要解决的问性能不是高性能的并发读写， 而是保证海量数据存储的同时,具有良好的查询性能 MongoDB 最大的特点是他支持的查询语言非常强大 其语法有点类 似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的 绝大部分功能，而且还支持对数据建立索引 1. 条件操作符 最简单 最常用 $gt : &gt; 大于 : field &gt; value $lt : &lt; 小于: field &lt; value $gte: &gt;= 大于等于: field &gt;= value $lte: &lt;= 小于等于: field &lt;= value $ne : !=或&lt;&gt; 不等于: fidld != value 示例： db.collection.find(&#123;&quot;field&quot;:&#123;$gt:value&#125;&#125;); 如果要同时满足多个条件，可以这样做 db.collection.find(&#123;&quot;field&quot;:&#123;$gt:value1,$lt:value2&#125;&#125;); value1 &lt; field &lt; value2 2. $in 包含 与sql标准语法的用法一样,即要查询age的值在20,24,26范围内的数据 db.users.find(&#123;“age”:&#123;$in:[20,24,26]&#125;&#125;); 3. $nin 不包含 $nin 跟$in 操作相反.要查询age的值不包含20,24,26的数据。 db.users.find(&#123;“age”:&#123;$nin:[20,24,26]&#125;&#125;); 4. $exists 判断字段是否存在 查询所有存在age字段的记录 db.users.find(&#123;age: &#123;$exists: true&#125;&#125;); 查询所有不存在name字段的记录 db.users.find(&#123;name: &#123;$exists: false&#125;&#125;); 5. $mod 取模运算符 查询age取模10等于0的数据 db.users.find(&#123;age:&#123;$mod:[10,1]&#125;&#125;); 查询age取模6等于1的数据 db.c1.find(&#123;age:&#123;$mod:[6,1]&#125;&#125;); 6. $or匹配符合条件的（和$in类似） 查找name等于zhangsan，age等于24的，有一个条件成立的就可以查找出来 db.users.find(&#123;$or:[&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;,&#123;&quot;age&quot;:24&#125;]&#125;); 7. $nor和$or的用法相反 name等于zhangsan或age等于24,其中一个条件成立就过滤掉。 db.users.find(&#123;$nor:[&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;,&#123;&quot;age&quot;:24&#125;]&#125;);8. 正则表达式匹配 MongoDB使用的Perl兼容的正则表达式，使用前可以查 看一下javascript中检查一下语法。 db.users.find({name: {$not: /job/}});Select from where name link ‘%job%’db.users.find({name: {$not: /^job/}});Select from where name link ‘job%’123459. 分页相关的查询 db.users.find(...).count() 返回记录总数 db.users.find(...).limit(n) 返回限定数量 db.users.find(...).skip(n) 限定起始位置 db.users.find(...).sort(字段,1) 排序1为升序，-1为降序 db.users.find({“name”: “新款冬装”}).count() //总数db.users.find({“name”: “新款冬装”}).skip(5).limti(10).sort(“date”,-1)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485查询名字为‘新款冬装’的记录，从第5条以后开始取，一共取10条，按时间最新排序（sort 1为升序，-1为降序）。 10. $where如果上述讲的所有条件都不能满足时，就需要用到$where，用它可以执行任意的javascript代码作为查询条件。如： `db.users.find(&#123;“$where”:”function()&#123;returnthis.x+this.y==10&#125;”&#125;);` 这样就可以把代码执行的结果作为查询的条件。注意：不是非常必要时，一定不要使用$where,因为它在查询速度上比常规查询慢很多，每个文档有要从BSON转换成javascript对象，然后在$where来运行，并且还不能使用索引 Capped Collection 固定集合==== capped collections是性能出色的有着固定大小的集合，以LRU(Least Recently Used最近最少使用)规则和插入顺序进行age-out(老化移出)处理，自动维护集合中对象的插入顺序，在创建 时要预先指定大小。如果空间用完，新添加的对象将会取代集合中最旧的对象 永远保持最新的数据 功能特点 可以插入及更新，但更新不能超出 collection 的大小，否则更新失败。不允许删除，但是可以调用 drop()删除集合中的所有行，但是 drop 后需要显式地重建集合。在32位机上一个capped collection的最大值约482.5M,64 位上只受系统文件大小的限制。 属性及用法 属性1：对固定集合进行插入速度极快 属性2：按照插入顺序的查询输出速度极快。 属性3：能够在插入最新数据时，淘汰最早的数据。 用法1：储存日志信息。 用法2：缓存一些少量的文档 1. 创建固定集合 不像普通集合，固定集合需要显式的创建使用createCollection命令来创建。 `db.createCollection(“my_collection”,&#123;capped:true,size:10000&#125;)` 创建一个集合为‘my_collection’的固定集合，大小为10000字节。还可以限定文档个数。加上 Max:100 属性。注意：指定文档上限，必须指定大小。文档限制是在容量没满时进行淘汰，要是满了，就根据容量限制来进行淘汰。 2. 转换集合 把普通的集合转换成固定集合需要使用convertTocapped命令 `db.runCommand(&#123;convertTocapped:”test”,size:10000&#125;)`把test普通集合转换为固定集合，大小为10000字节。自然排序固定集合文档按照插入顺序储存的，默认情况下查询就是按照插入顺序返回的，也可以使用$natural调整返回顺序。 `db.my_collection.find().sort(&#123;“$natural”:1&#125;)` 1表示默认顺序，-1则相反。#判断用db.c2.isCapped();#db.c2.status(); GridFS ====GridFS是一种在MongoDB中存储大二进制文件 的机制，使用GridFS的原因有以下几种：储存巨大的文件，比如视频、高清图片等。利用GridFS可以简化需求。GridFS会直接利用已经建立的复制或分片机制，故障恢复和扩展都很容易 GridFS可以避免用户上传内容的文件系统出现问题。GridFS不产生磁盘碎片 GridFS使用两个表来存储数据： files 包含元数据对象 chunks 包含其他一些相关信息的二进制块 为了使多个 GridFS 命名为一个单一的数据库，文件和块都有一个前缀，默认情况下，前缀是 fs，所以任何默认的 GridFS 存储将包括命名空间fs.files 和 fs.chunks。各种第三方语言可以更改其前缀* 使用FridFS mongofiles 是从命令行操作GridFS的一种工具三个命令：put(存储) get(取得) list(列表)例如:我们将”testfile”这个文件存到库里面，具体用法如下： [root@localhost bin]# ./mongofiles put testfileconnected to: 127.0.0.1added file: { _id: ObjectId(‘4fc60175c714c5d960fff76a’), filename: “testfile”, chunkSize: uploadDate: new Date(1338376565745), md5: “8addbeb77789ae6b2cb75deee30faf1a”, 16 }done!123下面我们查一下看库里有哪些GridFS文件，在”mongofiles”后加一个参数”list”即可 [root@localhost bin]# ./mongofiles listconnected to: 127.0.0.1testfile 16 –大小1接下来我们进库里看一下是否有新的东西 show collectionsfs.chunks –上文提到的fs.chunksfs.files –上文提到的fs.files1我们继续查看fs.files中的内容 db.fs.files.find(){ “_id” : ObjectId(“4fc60175c714c5d960fff76a”), “filename” : “testfile”, “chunkSize” “uploadDate” : ISODate(“2012-05-30T11:16:05.745Z”), “md5” :“8addbeb77789ae6b2cb75deee30faf1a”, “length” : 16 }123456789字段说明: Filename: 存储的文件名 chunkSize: chunks分块的大小 uploadDate: 入库时间 md5: 此文件的md5码 length: 文件大小,单位”字节” fs.files中存储的是一些基础的元数据信息 | 继续查看 db.fs.chunks.find(){ “_id” : ObjectId(“4fc60175cf1154905d949336”), “files_id” :ObjectId(“4fc60175c714c5d960fff76a”), “n” : 0, “data” :BinData(0,”SGVyZSBpcyBCZWlqaW5nCg==”) }12345_id:块自身的id files_id:包含这个块的元数据文档文件id n: 它代表的是chunks的序号，此序号从0开 data :组成文件块的二进制文件 fs.chunks中存储的是一些实际的内容数据信息 [root@localhost bin]# rm testfilerm：是否删除 一 “testfile”? y –先删文件[root@localhost bin]# ./mongofiles get testfile –将其从库里取出来connected to: 127.0.0.1done write to: testfile[root@localhost bin]# md5sum testfile –校验md5，结果跟库123456789101112131415161718索引以及性能优化和性能监控 === 1. 索引 MongoDB 提供了多样性的索引支持，索引信息被保存在system.indexes中，MongoDB中_id字段在创建的时候，默认已经建立了索引，这个索引比较特殊，并且不可删除，不过 Capped Collections 例外。 * 建立索引（普通索引） 建立索引的函数：ensureIndex() 例子：在name上建立索引 1(升序)，-1(降序) `&gt;db.persons.ensureIndex(&#123;name:1&#125;);` 当系统已有大量数据时，创建索引非常耗时，需在后台执行，只需指定 “backgroud:true”即可 `&gt;db.t3.ensureIndex(&#123;age:1&#125;,&#123;background:true&#125;)`2. 唯一索引 只需在ensureIndex命令中指定”unique:true”即可创建唯一索引。例如，往表 t4 中插入2 条一样的记录 。 db.t4.insert({firstname: “wang”, lastname: “wenlong”});db.t4.insert({firstname: “wang”, lastname: “wenlong”});1在t4表中建立唯一索引 db.t4.ensureIndex({firstname: 1, lastname: 1}, {unique: true});E11000 duplicate key error index:test.t4.$firstname_1_lastname_1 dup key: { : “wang”, : “wenlong” }12345678可以看到，当建唯一索引时，系统报了错，具体原因就是因为表中有2条一样的数据，所以建立不了唯一索引。3. 查看索引 查看索引使用的命令 getIndexes()上例显示出来的一共有 2 个索引，其中_id是创建表的时候自动创建的索引，此索引是不能够删除。 4. 删除索引 删除索引分为： 命令：dropIndexe () //删除 t3表中的所有索引db.t3.dropIndexes()//删除 t4表中的 firstname 索引db.t4.dropIndex({firstname: 1})123453.性能优化 * explain 执行计划 MongoDB 提供了一个explain命令让我们获知系统如何处理查询请求。利用explain命令我们可以很好地观察系统如何使用索引来加快检索，同时可以针对性优化索引。 db.t5.ensureIndex({name:1})db.t5.ensureIndex({age:1})db.t5.find({age:{$gt:45}}, {name:1}).explain(){“cursor” : “BtreeCursor age_1”, 返回游标类型(BasicCursor 或 BtreeCursor)“nscanned” : 0, 被扫描的文档数量“nscannedObjects” : 0,“n” : 0, 返回的文档数量“millis” : 0, 耗时(毫秒)“indexBounds” : { 所使用的索引“age” : [[45,1.7976931348623157e+308]]}}12345678910 * 优化器 profile MongoDB Database Profiler 是一种慢查询日志功能，可以作为我们优化数据库的依据。开启Profiling功能 有两种方式可以控制 Profiling 的开关和级别。启动MongoDB时加上–profile=级别即可。在客户端调用 db.setProfilingLevel(级别)命令来实时配置。 Profiler 信息保存在 system.profile 中。我们可以通过db.getProfilingLevel()命令来获取当前的Profile级 db.setProfilingLevel(2);{ “was” : 0, “slowms” : 100, “ok” : 1 }db.getProfilingLevel();212345678910111213上面profile的级别可以取0,1,2三个值，它们的表示： 0 – 不开启 1 – 记录慢命令 (默认为&gt;100ms) 2 – 记录所有命令 | Profile 在级别1时会记录慢命令, 上面的默认值为100ms，有默认就有设置，其设置方法和级别有两种方法： 一种是通过添加–slowms 启动参数配置。db.setProfilingLevel时加上第二个参数。那么这个慢的定义是什么? 可以理解比较耗时的命令，如一个查询耗时10毫秒，就会被记录下来。 db.system.profile.find().sort({$natural:-1}).limit(1){ “ts” : ISODate(“2012-05-20T16:50:36.321Z”), “info” : “query test.system.profile reslen:1219nscanned:8 \\nquery: { query: {}, orderby: { $natural: -1.0 } } nreturned:8 bytes:1203”, “millis” 0 }`字段说明:ts： 该命令在何时执行info: 本命令的详细信息reslen: 返回结果集的大小nscanned: 本次查询扫描的记录数nreturned: 本次查询实际返回的结果集millis: 该命令执行耗时，以毫秒记一个比较简洁的命令 show Profile,可列出最近5 条执行时间超过1ms的Profile 记录 优化方案 创建索引 在查询条件的字段上，或者排序条件的字段上创建索引，可以显著提高执行效率。db.posts.ensureIndex({ts:1}); 坚定返回结果条数使用limit()限定返回结果集的大小，可以减少databaseserver 的资源消耗，可以减少网络传输数据量。db.posts.find().sort({ts:-1}).limit(10); 查询使用到的字段，不查询所有字段db.posts.find({},{ts:1,title:1,author:1,abstract:1}).sort({ts:-1}).limit(10); 采用cappedcollectioncapped Collections比普通Collections的读写效率高 采用Profiling Profiling 功能肯定是会影响效率的，但是不太严重，原因是他使用的是system.profile来记录,system.profile是一个capped collection 这种collection 在操作上有一些限制和特点，但是效率更高。 余下的还有管理篇，构架篇，实操篇，太多了，具体看文档和书籍吧","categories":[],"tags":[{"name":"Mongodb","slug":"Mongodb","permalink":"http://yoursite.com/tags/Mongodb/"}]},{"title":"memcache相关","slug":"memcache相关","date":"2018-10-13T04:15:31.000Z","updated":"2018-10-22T13:56:14.804Z","comments":true,"path":"2018/10/13/memcache相关/","link":"","permalink":"http://yoursite.com/2018/10/13/memcache相关/","excerpt":"memcache的优缺点* 快速缓存 * 跨域登录 * 复杂的数据存取的操作 * 不能永久保存数据 memcache的安装（windows下） memcached.exe -d install memcached.exe -d uninstall memcached.exe -d start memcached.exe -d stop","text":"memcache的优缺点* 快速缓存 * 跨域登录 * 复杂的数据存取的操作 * 不能永久保存数据 memcache的安装（windows下） memcached.exe -d install memcached.exe -d uninstall memcached.exe -d start memcached.exe -d stop 调优 “C:\\memcache\\memcache.exe” -m -u root -l 192.168.20.2 -p 10000 -d runservice memcache的安装（linux下） ./configure &amp;&amp; make &amp;&amp; make install memcache -d -m 2048 -u root -l 192.168.20.1 -p 10000 pkill memcached 查看memcache的服务状态（window下） 查端口netstat -ano|find ‘10000’ 备注： -a 显示所有连接和监听端口 -n 以数字形式显示地址和端口号，此选项可以同-a组合使用 -o 显示与每个连接相关的所属进程 查进程 tasklist|find”memcache” 查看memcache服务状态 (linux下) 查端口 netstat -tunpl|grep 10000 查进程 pstree|grep memcache 增删改查 增： set name 0 3600 5 user1 查： 1.states 2.get name 3.stats items 4.stats cachedump 1 0 删： delete name 改： replace name 0 3600 4 user php下操控memcache 连接memcache服务器 $mem = new Memcache:$mem -&gt;connect(“192.168.20.1”,”10000”); 增$mem -&gt;set(“naame”,”user1”); 删$mem -&gt;&gt;delete(“name”); 改$mem -&gt;set(“age”,200); 查echo $mem-&gt;get(“age”); 查看状态$arr =$mem -&gt;getstat(); 清空$mem-&gt;flush(); 其他的就查询php手册 memcache 实现跨服务器登录 php.ini配置文件修改 session.save_handler =memcache; session.save_path = &quot;tcp://192.168.20.1:11211&quot;","categories":[],"tags":[{"name":"memcache","slug":"memcache","permalink":"http://yoursite.com/tags/memcache/"}]},{"title":"yaf相关","slug":"yaf相关","date":"2018-10-12T17:30:34.000Z","updated":"2018-10-22T13:57:04.471Z","comments":true,"path":"2018/10/13/yaf相关/","link":"","permalink":"http://yoursite.com/2018/10/13/yaf相关/","excerpt":"yaf yaf的配置 名字 默认 说明 yaf.eviron product 环境名称，可用ini作为yaf的配置文件时，这个指明了yaf将要啊在ini配置中读取的节的名字 yaf.libarary null 全局库类的目录路径 yaf.cache_config o 是否缓存配置文件（只针对ini配置文件生效），打开此选项可在复杂配置的情况下提高性能 yaf.nanme_suffix 1 在处理Controller，Action，Model的时候，类名中关键信息是否是后缀式，比如UserModel，前缀模式下则是ModelUser yaf..name_separator “” 在处理Controller，Action，Plugin，Model的时候，前缀和名字之间的分隔符，默认为空，也就是UserPlugin，假如设置为“_”，则会显示为User_Plugin，这个主要是为了兼容ST已有的命名规范 yaf.forward_limit 5 forward最大嵌套深度 yaf.use_namespace 0 yaf_Application将会变为yaf\\application yaf.use_spl_autoload 0 开启的情况下，yaf在加载不成功的情况下，会继续让php的自动加载函数加载，从性能考虑，除非特殊情况，否则保持这个选项关闭","text":"yaf yaf的配置 名字 默认 说明 yaf.eviron product 环境名称，可用ini作为yaf的配置文件时，这个指明了yaf将要啊在ini配置中读取的节的名字 yaf.libarary null 全局库类的目录路径 yaf.cache_config o 是否缓存配置文件（只针对ini配置文件生效），打开此选项可在复杂配置的情况下提高性能 yaf.nanme_suffix 1 在处理Controller，Action，Model的时候，类名中关键信息是否是后缀式，比如UserModel，前缀模式下则是ModelUser yaf..name_separator “” 在处理Controller，Action，Plugin，Model的时候，前缀和名字之间的分隔符，默认为空，也就是UserPlugin，假如设置为“_”，则会显示为User_Plugin，这个主要是为了兼容ST已有的命名规范 yaf.forward_limit 5 forward最大嵌套深度 yaf.use_namespace 0 yaf_Application将会变为yaf\\application yaf.use_spl_autoload 0 开启的情况下，yaf在加载不成功的情况下，会继续让php的自动加载函数加载，从性能考虑，除非特殊情况，否则保持这个选项关闭 本地可选配置 选项名称 值类型 默认值 说明 application.ext string php php脚本的拓展名 application.bootstrap string bootstrapapplication.php bootstrap路径（绝对路径） application.library string application.directory+”/library” 本地（自身）类库的绝对路径 application.baseUrl string null 在路径中需要忽视的路径前缀，一般不需要设置，yaf会自动判断 application.dispatcher.defaultModule string index 默认的模块 application.dispatcher.throwException bool true 在出错的时候，是否抛出异常 application.dispatcher.catchException bool false 在出错的时候，是否抛出异常。是否使用默认的异常捕获Controller，如果开启，在有未捕获的异常的时候，控制权会交给ErrorController的errorAction方法，可以通过$request-&gt;getException（）获得此异常对象 application.dispatcher.DefaultController string index 默认的控制器 application.dispatcher.defaultAciont sting index 默认的方法 application.view.ext string phtml 视图模块拓展名 application.modules string Index 声明存在的模块名，请注意，如果你一定要设置这个值，一定要……（看不懂，遇到网上查） application.system.* string * 手动导入类库 12345yaf\\Loadder::import(&quot;/usr/local/foo.php&quot;);//相对路径，会在APPLICATION_PATH.&quot;/library&quot;下加载 yaf\\Lodder::import(&quot;plugin/User.php&quot;);","categories":[],"tags":[]},{"title":"杂项","slug":"杂项","date":"2018-10-12T12:36:14.000Z","updated":"2018-10-22T13:57:24.530Z","comments":true,"path":"2018/10/12/杂项/","link":"","permalink":"http://yoursite.com/2018/10/12/杂项/","excerpt":"在一个命名空间里引入这个脚本，脚本里的元素不会归属到这个命名空间。如果这个脚本里没有定义其它命名空间，它的元素就始终处于公共空间中： &lt;?php namespace Blog\\Article; //引入脚本文件 include &apos;./common_inc.php&apos;; $filter_XSS = new FilterXSS(); //出现致命错误：找不到Blog\\Article\\FilterXSS类 $filter_XSS = new \\FilterXSS(); //正确 ?&gt; !一个拓展模块安装不上，是php将我的电脑识别为x86，可在phpinfo()的Architecture一栏看到.","text":"在一个命名空间里引入这个脚本，脚本里的元素不会归属到这个命名空间。如果这个脚本里没有定义其它命名空间，它的元素就始终处于公共空间中： &lt;?php namespace Blog\\Article; //引入脚本文件 include &apos;./common_inc.php&apos;; $filter_XSS = new FilterXSS(); //出现致命错误：找不到Blog\\Article\\FilterXSS类 $filter_XSS = new \\FilterXSS(); //正确 ?&gt; !一个拓展模块安装不上，是php将我的电脑识别为x86，可在phpinfo()的Architecture一栏看到. 遇到报错，[Linter] Error running PHP Error: PHP Warning: Module ‘yaf’ already loaded in Unknown on line 0.原因是重复加载，将php.ini中的extension=php_yaf.dll注释掉即可 原文解释：There are two ways to load most extensions in PHP. One is by compiling the extension directly into the PHP binary. The other is by loading a shared extension dynamically via an ini file. The errors indicate that dynamic extensions are being loaded via .ini files, even though they are already compiled into the PHP binary. php有两种方式加载拓展，一种是通过直接编译进php二进制文件中，另一种是通过ini文件动态加载一个拓展。 常用端口21:FTP文件传输服务;22:SSH命令行远程登录;25:SMTP邮件发送服务;80:HTTP网站服务;110:POP3邮件接收服务;139:SMB/SAMBA共享;143：IMAP邮件接收服务;443:HTTPS加密网站服务;3306:MYSQL数据库服务;3386:RDP远程桌面服务;6379:redis缓存服务器;8080:Proxy代理服务器 include和require的区别 两者用途相同。 require通常放在php的头部，导入文件。因为它无条件执行。 include通常放在php代码中，需要时执行. 本质区别在于对待错误的方式，require在存在错误时，会中断脚本，返回一个致命错误。include则不会中断执行，并弹出一个警告 主观错误 刚一个memcache的取值，一直取不出来。结果是点错文件了……以后小心 require_once 当前目录不用加”./“exit会直接终止php脚本，if里面会导致下面无法输出了php函数内外的变量不通，所以有global存在is_array空数组为真","categories":[],"tags":[]},{"title":"看源码的零碎收集","slug":"看源码的零碎收集","date":"2018-10-12T10:45:08.000Z","updated":"2018-10-22T13:57:31.807Z","comments":true,"path":"2018/10/12/看源码的零碎收集/","link":"","permalink":"http://yoursite.com/2018/10/12/看源码的零碎收集/","excerpt":"$_SERVER[&#39;REQUEST_METHOD&#39;] == &#39;POST&#39; 123456&lt;?php for ($x=0; $x&lt;8; $x++) &#123; ?&gt; &lt;?php for ($y=0; $y&lt;5; $y++) &#123; ?&gt; &lt;img src=&quot;output.php?n=&lt;?php echo 5*$x+$y; ?&gt;&quot; /&gt; &lt;?php &#125; ?&gt; &lt;br /&gt;&lt;?php &#125; ?&gt; require_once __DIR__.&#39;/../vendor/autoload.php&#39;;","text":"$_SERVER[&#39;REQUEST_METHOD&#39;] == &#39;POST&#39; 123456&lt;?php for ($x=0; $x&lt;8; $x++) &#123; ?&gt; &lt;?php for ($y=0; $y&lt;5; $y++) &#123; ?&gt; &lt;img src=&quot;output.php?n=&lt;?php echo 5*$x+$y; ?&gt;&quot; /&gt; &lt;?php &#125; ?&gt; &lt;br /&gt;&lt;?php &#125; ?&gt; require_once __DIR__.&#39;/../vendor/autoload.php&#39;; get_class 返回对象的类名 class_implements 返回指定的类实现的所有接口。 $a-&gt;b-&gt;c意思是说：1、$a对象是由（$a = new App()）App对象创建的。2、但是App类中还有一个字段（public $b;），该字段b也是一个对象。3、App类中的字段b是Action类型的，由（$a = new Action()）App对象创建的。4、但是Action类中还有一个字段（public $c;），该字段c也是一个对象。就这样循环下去了…… Dispatcher请求转发的意思。。。直接把客户端的请求在服务器处理以后跳转到下一个页面或者是处理类。。。此时的地址栏上的URL是不会变化的。。。。Redirect是重定向的意思。。。客户端的请求到达服务器处理以后，让客户端的页面链接重新定到另一个页面。。。此时地址栏的URL和你请求以前是不同 如果想捕捉 print_r() 的输出，可使用 return 参数。若此参数设为 TRUE，print_r() 将不打印结果（此为默认动作），而是返回其输出。 property_exists 检查对象或类是否具有该属性 0.14982900 1539836700 micortime();1539836772.456 microtime(true); $GLOBALS 在php代码中我们经常看到这样的写法： $max = $a&gt;$b ? $a : $b; mysql_connect($user,$passwd,$db) or die($mess); 下面对这两种常见的写法做以下说明： 第一种：典型的三元运算符形式 表达式的值成了，那么$max 的值是$a 否则$max 的值是$b，也就是说$max 的取值要么是$a 要么是$b，需要满足这样的情况 第二种：or 逻辑或运算 因为在PHP中并不区分数据类型，而且存在数据类型自动转换，所以在执行的时候会转换成bool值，并且or逻辑运算中会存在逻辑短路问题，刚好可以这样解释： 当or前面的表达式返还布尔值true的时候，or后面的表达式不再执行，但是当or前面的表达式返还false的时候，or后面的表达式要执行的。 之所以 用 or 可以达到，是因为当函数错误后，能执行or后面的函数，这是因为下面三点原因:1.逻辑运算的运算顺序是从左向右2.or运算符的左结合性3.or运算中，如果运算时有值为真了，则整个表达式为真，后面不需要运算 终合上面三个因素，当or左侧函数运行正常(返回非假值)，则不会执行后面的函数这里利用了or的这个特性，将die(终止并输出函数)用于此处，巧妙的实现了函数异常而报错的功能 常见的使用or的还有下面的这个 defined() or define(); 检查一个常量是否定义过，如果没有定义那么就定义一个常量。","categories":[],"tags":[{"name":"零碎","slug":"零碎","permalink":"http://yoursite.com/tags/零碎/"}]},{"title":"有关JWT","slug":"有关JWT","date":"2018-10-11T17:04:32.000Z","updated":"2018-10-22T13:57:21.303Z","comments":true,"path":"2018/10/12/有关JWT/","link":"","permalink":"http://yoursite.com/2018/10/12/有关JWT/","excerpt":"JWT是一种用于双方之间传递安全信息的简洁的，url安全的表述性声明规范。JWT作为一个开放的标准（RTC 7519），定义了一种简洁的，自包含的方法用以通信的双方以json对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT可以使用HMAC算法或者是RSA的公钥秘钥进行签名，简洁（compact）可以通过url，post参数或者在HTTP header发送，因为数据量小，传输速度也很快，自包含（self-contained）:负载中包含了所有用户所需要的信息，避免了多次查询数据库。 JWT的主要应用场景 身份认证这种场景下，一旦用户完成了登录，在接下来的每个请求中包含JWT,可以用来验证用户身份以及对路由，服务和资源的访问权限进行验证。由于它的开销非常小，可以轻松的在不同域名的系统中进行传递，所有目前在单点登录（SSO）中比较广泛的使用了该技术。信息交换在通信的双方之间使用JWT对数据进行编码是一种非常安全的方式，由于它的信息是经过签名的，可以确保发送者发送的信息是没有经历伪造的。","text":"JWT是一种用于双方之间传递安全信息的简洁的，url安全的表述性声明规范。JWT作为一个开放的标准（RTC 7519），定义了一种简洁的，自包含的方法用以通信的双方以json对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT可以使用HMAC算法或者是RSA的公钥秘钥进行签名，简洁（compact）可以通过url，post参数或者在HTTP header发送，因为数据量小，传输速度也很快，自包含（self-contained）:负载中包含了所有用户所需要的信息，避免了多次查询数据库。 JWT的主要应用场景 身份认证这种场景下，一旦用户完成了登录，在接下来的每个请求中包含JWT,可以用来验证用户身份以及对路由，服务和资源的访问权限进行验证。由于它的开销非常小，可以轻松的在不同域名的系统中进行传递，所有目前在单点登录（SSO）中比较广泛的使用了该技术。信息交换在通信的双方之间使用JWT对数据进行编码是一种非常安全的方式，由于它的信息是经过签名的，可以确保发送者发送的信息是没有经历伪造的。 JWT的结构 JWT包含了使用，分隔的三部分Header头部，Payload负载，Signature签名。 其结构看起来是这样的，Header.Payload.Signature Header在header中通常包含了两个部分，token类型和采用的加密算法那。{“alg”:”HS265”,”typ”:”JWT”},接下来对这部分使用Base64Url编码组成了JWT结构的第一部分 PayloadToken的第二部分是负载，它包含了claim，claim是一些实体（通常指用户）的状态和额外的元数据，有三种类型的claim：reserved,public和private。Reserved claaim是JWT预先定义的，在JWT中并不会强制使用它们，而是推荐使用，常用的有iss（签发着），exp（过期时间戳），sub（面向的用户），aud（接收方），iat（签发时间）。public claim：根据需要定义自己的字段，注意应该避免冲突。private claim：这些是自定义的字段，可以用来在双方之间交换信息负载使用。例子：{“sub”:”123456780”,”name”:”John Doe”,”admin”:true},上述的负载需要经过Base64Url编码后作为JWT结构的第二部分。 Signature创建签名需要使用编码后的header和payload以及一个秘钥，使用header中指定签名算法进行签名。例如希望使用HMAC SHA256算法，那么签名应该使用下列方式创建HMACSHA256( base64UrlEncode(header) + “.” + base64UrlEncode(payload), secret）。签名用于验证消息的发送者以及消息是没有经历篡改的。完整的JWT格式的输出是以”.”分隔的三段Base64Url编码，如下如何使用JWT?在身份鉴定的实现中，传统方法是在服务端存储一个session，给客户端返回一个cookie。而使用JWT之后，当用户使用它的认证信息登录系统之后，会返回给用户一个JWT，用户只需要本地保存该token（通常使用local storage，也可以使用cookie）即可，当用户希望访问一个收保护的路由或者资源的时候，通常应该在Authorization头部使用Bearer模式添加JWT，其内容看起来下面这样的：Authorization： Bearer 因为用户的状态在服务端的内存中是不存储的，所以这是一种无状态的认证机制。服务端的保护路由将会检查请求头Authorization中的JWT信息，如果合法，则允许用户的行为。由于JWT是自包含的，因此减少了需要查询数据库的需要。 JWT的这些特性使得我们可以完全依赖其无状态的特性提供数据API服务，甚至是创建一个下载流服务。因为JWT并不使用Cookie的，所以你可以使用任何域名提供你的API服务而不需要担心跨域资源共享问题（CORS）。 下面的序列图展示了该过程： 为什么要使用JWT？ 相比XML格式，JSON更加简洁，编码之后更小，这使得JWT比SAML更加简洁，更加适合在HTML和HTTP环境中传递。 在安全性方面，SWT只能够使用HMAC算法和共享的对称秘钥进行签名，而JWT和SAML token则可以使用X.509认证的公私秘钥对进行签名。与简单的JSON相比，XML和XML数字签名会引入复杂的安全漏洞。 因为JSON可以直接映射为对象，在大多数编程语言中都提供了JSON解析器，而XML则没有这么自然的文档-对象映射关系，这就使得使用JWT比SAML更方便 java json web token工具类 例子 官网的例子： 12HMACSHA256( base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),secret) 自己写的 123456789101112131415161718&lt;?php function base64Url_encode($data)&#123; return rtrim(strtr(base64_encode($data),&quot;+/&quot;,&quot;-_&quot;),&quot;=&quot;); &#125; function base64Url_decode($data)&#123; return base64_decode(str_pad(strstr($data,&quot;-_&quot;,&quot;+/&quot;),strlen($data)%4,&apos;=&apos;,STR_PAD_RIGHT)); &#125; public static function encode(array $payload,string $key,string $alg =&quot;SHA256&quot;)&#123; $key = md5($key); $jwt = self::urlsafeB64encode(Json_encode([&apos;type&apos;=&gt;&quot;JWT&quot;,&apos;alg&apos;=&gt;$alg])) . &quot;.&quot; . self:urlsafeB64encode(json_encode($payload)); return $jwt . &quot;.&quot; .self::signature ($jwt,$key,$alg); &#125; public static function signture(string $input,string $key ,string $alg)&#123; return hash_hmac($alg, $input ,$key); &#125; 登录过程： 第一次认证：第一次登录，用户从浏览器输入用户名/密码，提交后到服务器的登录处理的action层（Login Action） Login Action 调用认证服务进行用户名密码认证，如果认证通过，Login Action层调用用户信息服务获取用户信息（包括完整的用户信息及对应权限信息）。 返回用户信息后，login action从配置文件中获取token签名生存的秘钥信息，进行token生成 生成token的过程中可以调用第三方的JWT Lib生成签名后的JWT数据。 完成JWT数据签名后，将其设置道cookie对象中，并重定向到首页，完成登录过程。 JWT服务端验证过程基于token的认证机制会在每一次请求中都带上完成签名的token信息，这个token信息可能在cookie中，也可能在http的Authorization头中。 1. 客户端（APP客户端或浏览器）通过GET或POST请求访问资源（页面或者调用API） 2. 认证服务作为一个Middelware HOOK对请求进行拉拦截，首先在cookie中查找token信息，如果没有找到，则在HTTP Authorization Head中查找 3. 如果找到Token信息，则根据配置文件中的签名加秘钥，调用JWT Lib对token信息进行解密和解码； 4. 完成解码并验证签名通过后，对token中的exp，nbj，aud等信息进行验证。 5. 全部通过后，根据获取用户的角色权限信息，进行对请求的资源的权限逻辑判断。 6. 如果权限逻辑判断案通过则通过Response对象返回，否则返回HTTP 401 1234567891011121314151617181920212223242526272829&lt;?PHP public static function decode(string $jwt,string $key) &#123; $token = explode(&quot;.&quot;$jwt); $key = md5($Key); if(count($tonke) != 3) &#123; return false; &#125; list($header64,$payload64,$sing) =$token; $header =json_decode(self::urlsafeB64Decode($header64),JSON_OBJECT_AS_ARRAY); if(empty($header[&apos;alg&apos;])) return false; if(self::signature($header64 . &quot;.&quot; . $payload64 , $key ,$header[&apos;alg&apos;]) !==$sing) return false; $payload = json_decode(self::urlsafeB64Decode($payload64),JSON_OBJECT_AS_ARRAY); $time = $_SERVER[&quot;REQUEST_TIME&quot;]; if(isset[&apos;iat&apos;] &amp;&amp; $payload[&apos;iat&apos; &gt; $time]) return false; if(isset[&apos;exp&apos;] &amp;&amp; $payload[&apos;exp&apos; &lt; $time]) return false; &#125; return $payload; 优秀之处 支持跨域访问：cokkie是不允许跨域访问的，这点对token机制不存在，前提是传输的用户认真信息通过HTTP头传输 去耦：不需要绑定到一个特定的身份验证方案。token可以在任何地方生成，只要你的API被调用的时候，你可以进行token的生成调用即可。也可以用一套token认证代码来面对浏览器类客户和非浏览器类客户。 更适合于移动应用： 当客户端是一个原生平台（ISO , ANDROID ,WINDOW 8等），cookie是不被支持的，这时采用token认证机制就会简单很多。 CSRF： 因为不在依赖于cooke，所以就不需要 考虑对CSRF（跨站请求伪造）的防范。 性能： token中包含足够多的信息，在后续请求中减少了查询数据库的几率 基于标准化：你的API可以采用标准化的JSON Web Token（JWT），这个标准以及存在于多个后端库（.NET,RUBY,JAVA,PYTHON,PHP)和多家公司支持(FIREBASE,GOOGLE,MICROSOFT) 如何确保安全1. 在传输敏感信息的过程中，建议采用HTTP5,通过SSL加密传输，确保通道的安全. 2. 在前后端做好过滤，防止SQL注入","categories":[],"tags":[{"name":"JWT","slug":"JWT","permalink":"http://yoursite.com/tags/JWT/"}]},{"title":"笔记记录-cookie和session相关","slug":"笔记记录-cookie和session相关","date":"2018-10-11T14:39:19.000Z","updated":"2018-10-22T13:57:35.728Z","comments":true,"path":"2018/10/11/笔记记录-cookie和session相关/","link":"","permalink":"http://yoursite.com/2018/10/11/笔记记录-cookie和session相关/","excerpt":"http协议本身没有状态 网络通过http协议来传递信息，它无法记录用户上网的信息，上过哪个网站，有什么爱好，无法记录用户的ID和密码，这便是http协议的无状态，这是符合http协议本身的目的的。客户端只需要请求服务端下载文件等，并不需要记录彼此过去的行为。每一次请求都是独立的，好比一个顾客和一个自动贩售机的关系。 怎么理解cookie和session","text":"http协议本身没有状态 网络通过http协议来传递信息，它无法记录用户上网的信息，上过哪个网站，有什么爱好，无法记录用户的ID和密码，这便是http协议的无状态，这是符合http协议本身的目的的。客户端只需要请求服务端下载文件等，并不需要记录彼此过去的行为。每一次请求都是独立的，好比一个顾客和一个自动贩售机的关系。 怎么理解cookie和session 打个比方，一个小店老板搞促销，消费期间累积十个商品再送一个，以下有三种方式： 老板凭借记忆力去记住每一位客户的消费数量，但这不现实，这记忆力非人。同时http协议无状态，也不能要求协议本身记录信息。 颁发积分卡.消费者来了的时候，办卡。每次消费，记上数量，还给消费者。当消费者再来时，携上积分卡，曾经的信息一目了然。这就是cookie技术，windows系统下，打开C:\\Documents and Setting\\用户名\\cookie(不同浏览器的存储路径会不相同，这里仅举例),会发现很多.txt格式的小文件，这便是个人在诸多网站上的“积分卡”. 仅有ID的会员卡。同样是办卡，这回给顾客的卡仅有ID。而老板以笔记形式记录客户的以往消费行为，并将笔记册子保存在店内。每次有会员卡来，对着册子，就能得到册子里记录过的消息。 所以cookie的信息保存在客户端，内容繁多。而session的信息保存在服务端，仅有一条ID信息作为凭证交给了顾客为cookie。 cookie和session有什么作用 通常用来保持用户的登录状态，以及购物车等。 什么是cookie（以下为复制 ） 1、什么是cookie？0Cookie技术是一个非常有争议的技术，自经诞生它就成了广大网络用户和Web开发人员的一个争论焦点。有一些网络用户，甚至包括一些资深的Web专家也对它的产生和推广感到不满，这倒不是因为Cookie技术的功能太弱或别的技术性能上的原因，而仅仅是因为他们觉得Cookie的使用，对网络用户的隐私构成了危害。因为Cookie是由Web服务器保存在用户浏览器上的小文本文件，它包含有关用户的信息（如身份识别号码、密码、用户在Web站点上购物的方式或用户访问该站点的次数）。 那么Cookie技术究竟怎样呢？是否真的给网络用户带来了个人隐私的危害呢？还是让我们看了下面的内容，再做回答吧。 在WEB技术发展史上，Cookie技术的出现是一个重大的变革。最先是Netscape在它的Netscape Navigator 浏览器中引入了Cookie技术，从那时起，World Wide Web 协会就开始支持Cookie标准。以后又经过微软的大力推广（因为微软的IIS Web服务器所采用的ASP技术很大程度的使用了Cookie技术），即在微软的Internet Explorer浏览器中完全支持Cookie技术。到现在，绝大多数的浏览器都支持Cookie技术，或者至少兼容Cookie技术的使用。 按照Netscape官方文档中的定义，Cookie是在HTTP协议下，服务器或脚本可以维护客户工作站上信息的一种方式。Cookie是由Web服务器保存在用户浏览器上的小文件，它可以包含有关用户的信息（如身份识别号码、密码、用户在Web站点购物的方式或用户访问该站点的次数）。无论何时用户链接到服务器，Web站点都可以访问Cookie信息。 如果你使用的是windows系统，那么请打开C:\\Documents and Settings\\用户名\\Cookies，你会发现该目录下有好多*.txt格式的小文件。那就是cookie文件。当然，在该目录下你也可能什么都发现不了，那时因为你新装了系统或者从未浏览过因特网，也或者你的浏览器禁用了cookie。否则该目录下总会有点东西的。 通俗地讲，浏览器用一个或多个限定的文件来支持Cookie。这些文件在使用Windows操作系统的机器上叫做Cookie文件，在Macintosh 机器上叫做magic Cookie 文件，这些文件被网站用来在上面存储Cookie数据。网站可以在这些Cookie文件中插入信息，这样对有些网络用户就有些副作用。有些用户认为这造成了对个人隐私的侵犯，更糟的是，有些人认为Cookie是对个人空间的侵占，而且会对用户的计算机带来安全性的危害。 目前有些Cookie是临时的，另一些则是持续的。临时的Cookie只在浏览器上保存一段规定的时间，一旦超过规定的时间该Cookie就会被系统清除。例如在PHP中Cookie被用来跟踪用户进程直到用户离开网站。持续的Cookie则保存在用户的Cookie文件中，下一次用户返回时，仍然可以对它进行调用。 在Cookie文件中保存Cookie，一些用户会过分地认为这将带来很大的问题。主要是有些用户担心Cookie会跟踪用户网上冲浪的习惯，譬如用户喜爱到那些类型的站点、爱从事些什么活动等。害怕这种个人信息一旦落入一些别有用心的家伙手中，那么个人也就可能成为一大堆广告垃圾的对象，甚至遭到意外的损害。不过，这种担心压根儿不会发生，因为网站以外的用户是无法跨过网站来获得Cookie信息的。所以想以这种目的来应用Cookie是不可能的。不过，由于一些用户错误的理解以及“以讹传讹”，一些浏览器开发商别无选择，只好作出相适的响应（例如Netscape Navigator4.0和Internet Explorer3.0都提供了屏蔽Cookie的选项）。个人认为，无风不起浪，如果网站程序员没有严谨思路的话，cookie确实也存在些许安全问题，不过这些瑕疵并不足以掩盖cookie的优秀品质，大多数人还是非常乐意使用它的。 对Cookie技术期待了这么久的结果是，迫使许多浏览器开发商在它们的浏览器中提供了对Cookie的灵活性控制功能。例如，目前的两大主流浏览器 Netscape Navigator 和 Internet Explorer是这样处理Cookie的:Netscape Navigator4.0不但可以接受Cookie进行警告，而且还可以屏蔽掉Cookie；InternetExplorer3.0也可以屏蔽 Cookie，但在Internet Explorer4.0中就只能进行接受警告而没有提供屏蔽选项，不过在Internet Explorer4.0之后的更新版本中又加入了屏蔽Cookie的功能选项。 此外，很多最新的技术甚至已经可以在不能屏蔽Cookie的浏览器上进行Cookie的屏蔽了。例如，可以通过将Cookie文件设置成不同的类型来限制 Cookie的使用。但是，非常不幸地是，要是你想完全屏蔽Cookie的话，肯定会因此拒绝许多的站点页面。因为当今已经有许多Web站点开发人员爱上了Cookie技术的强大功能，例如Session对象的使用就离不开Cookie的支持。 cookie的基本运行 当客户访问某个基于php的网站时，在php中可以使用setcookie函数生成一个cookie，系统处理后会将这个cookie发送并保存在客户端。cookie是http头的一部分，因此setcookie函数必须在任何内容输出之前调用，如同header（）。当客户再次访问时，浏览器会读取cookie添加到请求的头部，发送至服务端。php5中，cookie将被存储如$_Cookie之中。 又如： 小明访问某一个网站的登录页面，此时浏览器发送了一个http_request的请求，此时http header头中的cookie是空的。 服务器收到请求后，接受小明的登录数据，验证后，会返回一个cookie。通常是将小明的用户名发送给客户端。像“set-Cookie: session-id=12456;”这个字符串童工http response 返回给客户端。 浏览器收到http response后，发现携带有cookie，就将该信息写入浏览器的某个存储文件之中。 4.当小明再次访问时，请求的http request中就会有这个cookie 5.最后服务器端根据cookie进行操作，返回数据 cookie注意事项 setcookie不能有任何的输出。 cookie和session的存储 session一般保存在服务器端文件中，php.ini中有个配置项–session.save_path=””,这里填写路径，将会使得session文件保存在该路径下。session文件的命名格式是“sess_[PHPSESSID]”。每一个文件，里面保存了会话的数据。而cookie保存在客户端浏览器中。 session文件具体内容 保存的是一些序列化后的值 每个session的值以分号；分开，比如’cityName:|s:3:”all”;’就是一个完整的session值 SESSION_START()干了什么 session_start()已经封装了发送cookie的操作（发送一个名称为PHPSESSID的cookie到浏览器）。这又涉及到了一个http的原理：头部信息必须在内容之前发送，所以在使用此函数之前，不能有任何的输出 session的调用机制 用户球球服务端的login,php，填写数据提交 服务端验证后提取用户的数据，并将数据存入session，将session_id存入cookie，发给客户端 客户端保存 再次访问时，这个cookie通过header头发动诶服务器端 服务器获取 共享session的方式 在服务器端使用文件同步工具，复制session 速度慢，复制数据会出现延迟，不具备扩展性。开销大，对网络带宽和硬件都有大负担。 session通过加密存储在客户端cookie 可减小服务器压力 网络请求占用多 cookie大小存在限制 存在安全问题 淘宝曾经用过这种方式， 规则访问 设计一种算法（简单理解为规则），什么机制下session是保存在哪台服务器下的，那么读取的时候就按照这种规则去读取，就能定位到原来的服务器。其原理是存session和取session都是同一服务器在操作，就不会涉及到共享的问题。具体实现是通过约定一种分发机制，也叫作sticky模式（粘性会话模式），同一用户的访问请求都被派送到同一服务器上面。 但若某台服务器挂了，会导致部分用户无法登录 **** session中间层 做一个session中间层，专门用来存储所有访问涉及到的session。也就是所有的session都存储在这里。服务器端统一从这里读取session数据。 NFS做中间层 通过NFS的方式，各个php服务器操作session数据的时候，是读取本地磁盘啊目录。但实际上是一个网络共享文件。各个服务器实际上操作的都是同一目录的文件。 关系型数据库做中间层 把session数据存在数据库，那么连session_start都没有必要执行了。 从数据库获取session数据，约定好数据过期，然后清理数据库的行。 有些做法跟这种思想类似的是ecshop，phpcms 坏处： 放在数据库内时，访问量小没有问题。大流量网站这么做，智慧拖慢速度，因为频繁查询数据库，会造成数据库性能瓶颈，在高并发情况下尤是如此。 小网站，同时一两万在线的情况下，应该没有什么问题。 非关系型数据库 将session数据保存在memcache，redis之类的内存数据库中，因为内存速度快，所以性能很高。大并发时候尤其何时，且方便统计在线人数，内存数据库系统能够控制内存中的过期数据自动失效（符合session的过期）","categories":[],"tags":[{"name":"cookie session","slug":"cookie-session","permalink":"http://yoursite.com/tags/cookie-session/"}]},{"title":"网络基础","slug":"网络基础","date":"2018-10-11T11:24:43.000Z","updated":"2018-10-22T13:57:46.639Z","comments":true,"path":"2018/10/11/网络基础/","link":"","permalink":"http://yoursite.com/2018/10/11/网络基础/","excerpt":"网络基础状态码基础 1xx Informational(信息性状态码) 接受的请求正在处理 2xx success （成功状态码） 请求正常处理完毕 3xx Redirection（重定向状态码）需要进行附加操作以完成请求 4xx Client Error（客户端错误状态码）服务器无法处理请求 5xx Server Error （服务端错误状态码） 服务器处理请求出错 常见的状态码 200 请求正常处理 301 永久性重定向 302 临时性重定向 401 请求需要认证 403 请求的对应资源禁止被访问 404 服务器无法找到相应资源 500 服务器内部错误 503 服务器正忙","text":"网络基础状态码基础 1xx Informational(信息性状态码) 接受的请求正在处理 2xx success （成功状态码） 请求正常处理完毕 3xx Redirection（重定向状态码）需要进行附加操作以完成请求 4xx Client Error（客户端错误状态码）服务器无法处理请求 5xx Server Error （服务端错误状态码） 服务器处理请求出错 常见的状态码 200 请求正常处理 301 永久性重定向 302 临时性重定向 401 请求需要认证 403 请求的对应资源禁止被访问 404 服务器无法找到相应资源 500 服务器内部错误 503 服务器正忙 GET和POST的区别 get的重点在于从服务器上获取资源，post的重点在于向服务器端发送资源 get传输数据是通过url请求，以field（字段）=value的形式，置于url后，并用“？”来连接，多个请求数据间用“&amp;”来连接，这种过程是用户可见的post传输数据通过http的post机制，将字段和对应的值存放在请求实体中发送给服务器，这个过程是用户不可见的 get传输的数据量小，因受url长度限制，但效率较高。 post可以传输大量数据，所以上传文件时只能用psot方式； get是不安全的，因为url可见，会泄露私密信息，如密码。所以post比get的安全性高。","categories":[],"tags":[{"name":"网络 基础","slug":"网络-基础","permalink":"http://yoursite.com/tags/网络-基础/"}]},{"title":"php数组基础","slug":"php数组基础","date":"2018-10-11T10:03:47.000Z","updated":"2018-10-22T13:56:23.248Z","comments":true,"path":"2018/10/11/php数组基础/","link":"","permalink":"http://yoursite.com/2018/10/11/php数组基础/","excerpt":"php数组基础 key的强制转换 包含有合法整型值的字符串会被转换为整型 浮点数和布尔值会被转化为整型 键名null会被转化为“” 数组和对象不能用为键名 相同键名，之前的会被覆盖 删除数组元素 unset之后，并不会重置数组的索引 数组遍历 for foreach array_walk,array_map 回调遍历 current和next ：内部指针遍历","text":"php数组基础 key的强制转换 包含有合法整型值的字符串会被转换为整型 浮点数和布尔值会被转化为整型 键名null会被转化为“” 数组和对象不能用为键名 相同键名，之前的会被覆盖 删除数组元素 unset之后，并不会重置数组的索引 数组遍历 for foreach array_walk,array_map 回调遍历 current和next ：内部指针遍历 数组的内部实现 实现数组使用了两个数据结构，一个是HashTable，另一个是bucket。 HashTable 结构体用于保存整个数组需要的基本信息. Bucket 结构体用于保存具体的数据内容 HashTable是什么 哈希表，是根据关键字（key value）而直接访问内存存储位置的数据结构。也就是说，它把键值通过一个函数的计算，映射到表中的某一个位置来访问记录，这加快了查找速度。使得普通的查找和插入，删除操作都可以在0（1）的时间内完成。这个映射函数成为哈希函数，存放记录的数组成为哈希数组。 1234567891011121314151617181920212223242526//HashTable的结构体表示typeof struct _hashtable&#123; uint nTableSize; //hash Bucket 的大小，最小为8，以2X增长 uint nTableMask; //nTableSize-1,索引取值的优化，193491848 &amp; 127 unit nNumOfElements; //hash Bucket 中当前存在的元素个数，count（）函数会直接返回此值 ulong nNextFreeElement; // 下一个数字索引的位置 Bucket *pInternalPointer; //当前遍历的指针。foreach比for快的原因之一，reset,current遍历函数使用 Bucket *PListHead; //存储数组头元素指针 Bucket *PListTail; //存储数组尾元素指针 Bucket **arrBuckets; //存储hash数组，实际的存储容器 unsigned char nApplyCount; // 记录当前hash Bucket被递归返回的次数（防止多次递归）&#125; HashTable；typeof struct bucket&#123; ulong h; //对char *key进行hash之后的值，或者用户指定的数字索引值 uint nKeyLength； //hash关键字的长度，如果数组索引为数字，此值为0 viod *pDate； //指向value，一般是用户数据的副本，如果是指针数据，则指向pDataPtr void *pDataPrt；//如果是指针数据，此值回指向真正的value，同时上面pData会指向此值 struct bucket *pListNext； //整个hash表的下一个元素 struct bucket *pListLsst； //整个hash表该元素的上一个元素 struct bucket *pNext；//存放在同一个hash bucket内的下一个元素 struct bucket *pLast；//存放在同一个hash bucket内的上一个元素 const char *arKey;保持当前key所对应的字符串值&#125; Bucket; 数组函数分类 数组遍历相关数组：prev，next，current，end，reset，each等 数组排序相关 如sort，rsort，asort，arsort，ksort，krsort，uasort，uksort等 数组查找相关： 如 in_array(),array_search,array_key_exists等 数组分割，合并相关： array_slice,array_splice,implode,array_chunk,array_conbine等 数组交并差 ：array_merge,array_diff,array_diff_,array_intersect,array_intersect_等 作为stack/queue的容器 : array_push,array_pop,array_shift 其他的数组操控 :array_fill,array_flip,array_sum,array_reverse等","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"php的底层运行原理(2)","slug":"php的底层运行原理-2","date":"2018-10-11T09:21:58.000Z","updated":"2018-10-11T17:44:30.684Z","comments":true,"path":"2018/10/11/php的底层运行原理-2/","link":"","permalink":"http://yoursite.com/2018/10/11/php的底层运行原理-2/","excerpt":"","text":"php的底层运行原理(2) php运行机制和原理 扫描(scanning):先进行语法分析和词法分析，然后将index.php内容变成一个个的语法片段（token）. 解析(parsing)：词法分析后，就需要根据一个个token去组成有意义的表达式。 parsing首先丢弃token array中多余的空格，然后将剩余的token转化成一个个的简单表达式。 编译(complication)：将表达式编译成中间码（opcode）。 执行（execution）：将中间码一条条的执行。 输出（output buffer）：将要输出的内容输出到缓冲区。 12345678910&lt;&gt;php$code = &lt;&lt;&lt;&apos;PHP_CODE&apos;&lt;?phpecho &apos;hello world&apos;;$data = 1+1;echo $data;PHP_CODE;print_r(token_get_all($code)); 分析这个返回结果我们可以发现，源码中的字符串，字符，空格都会原样返回。每个源代码中的字符，都会出现在相应的顺序处。 12345array( [0] = 316 //tokenid [1] = &quot;hello world&quot; //token 的内容 [2] = 3 //token所在的行数 ) Token ID (在zend内部该Token的对应码)具体的定义可以在zend_language_parser.h中找到 提高php代码运行效率 压缩代码，去处无用的注释和空白 尽量使用PHP内置函数或者拓展函数 用apc/xcache/opcache等缓存php的opcode 缓存复杂和耗时运算的结果 能异步处理的任务不要马上处理，如发邮件 php底层的变量存储123456789101112131415161718192021222324252627282930313233343536373839404142434445 typeof union _zvalue_value &#123; long zval; double zval; struct&#123; char *val; int len; &#125; HashTable *ht; zend_object_value obj; &#125; zvalue_value; struct _zval_struct&#123; zvalue_value value; //value zend_uint refcount__gc; zend_uchar type; //active type zend_uchar is_ref__gc; &#125;``` * cow特性 COW（copy on write）是内存优化的常见手段，即写时复制，只有在写入时才会真正复制一份内存进行修改。### php的垃圾回收机制 * 什么是垃圾 垃圾主要针对内存，如果一个对象struct，并没有任何变量引用它，那这个对象就是垃圾. * 虽php结束进程时会销毁所有变量，关闭所有打开的句柄资源，但为何清理垃圾 * 开启太多内存空间，导致内存溢出 * 长时间运行的php代码，例如守护进程 * 如何回收垃圾 1. 如何找到垃圾 在所有变量中找到垃圾，所有的变量get_defined_vars函数能够看到所有已经定义的变量，那意味着php本身能存储所有变量或已开辟的内存空间，具体在zend_globals.h中struct_zend_executor_globals中看到 struct _zend_executor_globals{ ... HashTable *active_symbol_table;//局部变量的符号表 HashTable symbol_table;//全局变量的符号表 ... } ``` 根据zend_uint refcount__gc和zend_uchar is_ref__gc来判断是否是垃圾 2. 如何清理 在5.2版本之前，根据refcount_gc是否为0； 但在5.3之后，采用了新的算法，引用计数系统中的同步周期回收算法（Concurrent Cycle Collection in Reference Counted System）来清除。 * 5.3中采用模拟删除每个疑似变量，将其变量引用减一，然后在有其他变量指向该值时进行模拟恢复。在对不恢复的变量进行删除。","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"php的底层运行原理","slug":"php的底层运行原理","date":"2018-10-11T04:01:08.000Z","updated":"2018-10-22T13:56:11.319Z","comments":true,"path":"2018/10/11/php的底层运行原理/","link":"","permalink":"http://yoursite.com/2018/10/11/php的底层运行原理/","excerpt":"php的底层运行原理 php的运行模式SAPI : Server Application Programming Interface 服务器端应用编程接口。它就是php和其他应用交互的接口，php脚本要执行有很多种方式，通过web服务器，或者直接在命令行下，也可以直接嵌入在其他程序中。 APIS 提供了一个和外部通信的接口，常见有五大运行模式：","text":"php的底层运行原理 php的运行模式SAPI : Server Application Programming Interface 服务器端应用编程接口。它就是php和其他应用交互的接口，php脚本要执行有很多种方式，通过web服务器，或者直接在命令行下，也可以直接嵌入在其他程序中。 APIS 提供了一个和外部通信的接口，常见有五大运行模式： CGI(Common Gateway Interface 通用网关接口) fsat-CGI( CGI的升级版) CLI ( Common Line Interface) isapi ( Internet Server Application Programming Interface,是微软提供的一套面向Internet服务的API接口) apache2handle ( 将php作为apache的模块，nigix类似) 其他 ( Continuity，embed，listspeed，milter等) CLI 的运行模式Common Line Interface 的简称，即php命令行接口，在windows和linux下都支持php-cli模式。它可以直接在命令行下运行，那就意味着不需要任何的http容器。例如php test.php 应用场景 定时任务 开发桌面应用就是使用php-cli和GTK包 开发shell脚本 优点和缺点 利用cronttab去跑php，可以给服务器减压，当然在这里有一个条件，那就是实时性不高。比如：sns中的好友动态，这个实时性要求不高，但是数据量比较大，这个时候定时跑的话，会给web服务器和数据库服务器分担不少的压力。 就是我们要定时去完成某一事情，比如，我要删除一个月前的用户留言，这个时候，写个php脚本用crontab去执行，一天跑一次，而不是手动去执行php脚本 无法为普通用户提供http服务 1234567891011121314151617181920&lt;?php print_r($argv); echo &quot;\\n&quot;; echo $argc; echo &quot;\\n&quot;;?&gt;root@ubuntu :~$ php test,php aaa ccc bbbarray( [0] =&gt; test.php //参数0，文件本身 [1] =&gt; aaa //参数1 [2] =&gt; ccc //参数2 [3] =&gt; bbb //参数3)4 //$argc的值，参数的总数 CGI运行模式Common Gateway Interface 通用网关接口。它是一段程序，通俗的讲，CGI就是一座桥，把网页和web服务器中的执行程序连接起来，它把http服务器接受的指令传递给执行程序，再把执行程序的结果返回给http服务器。CGI的跨平台性极佳，几乎可以在任何操作系统上实现。 执行过程 http服务器接受到用户请求后，例如index.php，会通过它配置的CGI服务来执行 生成一个php-cgi.exe进程，并执行php程序 执行的返回结果交给http服务器 应用场景 提供http服务 优点和缺点 跨平台，几乎可以在任何操作系统上实现。 web和server是独立的，结构清晰，可控性强 性能较差，来一个请求，fork一个进程，100个请求会fork100个进程，消耗资源较多(fork-and-execute模式)。 最近几年已经很少见到使用这种模式了 FASTCGI模式Fast Common Gateway Interface 快速通用网关接口，是一种让交互程序和web服务器通信的协议。FastCGI是CGI的增强版本，它致力于减少web服务器和CGI程序之间互动的开销，从而使得服务器可以同时处理更多的网页请求。 执行过程 web服务器确定，载入FastCGI进程管理器 FastCGI进程管理器会启动多个CGI进程等待web服务器的链接。 当客户端的请求到web server时，fastCGI进行管理器选择并且链接到一个CGI解释器。web server 将环境变量和标准输入发送到fastCGI子进程php-cgi fastCGI子进程完成处理后将标准输出和错误信息从同一连接返回至web server。当fastCGI子进程关闭连接时，请求便告处理完成。fastCGI子进程接着等待并处理来自fastCGI进程管理器（运行在web server中）的下一个连接。在CGI模式中，就此退出。 应用场景 提供http服务 优点和缺点 跨平台，几乎可以在任何操作系统上实现。 web和server 是独立的，结构清晰，可控性强，并不需要web 升级而变化 支持大并发 多进程，消耗较多内存 模块运行模式 模块模式指将php作为web服务器的一个模块运行. 应用场景 提供http服务 优点和缺点 安装配置方便，不需要安装代码解析程序 支持多线程，占用资源较少 支持大并发 服务网络I/O模型为什么在大访问量下Nginx的性能比Apache要高？ 两者采用的服务器的模式不一样 * Apache所采用的select网络I/O模型非常低效 * Nginx采用了最新的epoll（Linux 2.6内核）和Kqueue（freebsd）网络I/O模型。 两种网络模型的区别 select select 模式 应用层首先初始化FD_SET(填入需要检测的socket集合),然后调用select函数 内核对FD_SET所包含的所有socket进行逐个检测，如果某个socket有状态改变，则填入内部分配的一个数组，当素有socket都检查完成后，在将该数组copy到FD_SET中，然后返回应用层 select调用返回，应用层从返回的FD_SET中提取状态有发生改变的socket，并根据socket值映射客户端上下文（可以通过map或者hash_map来映射），然后处理收到的数据. EPOLL模式 应用层调用epoll_wait检测有事件发生的连接 内核对epoll_ctl注册事件的socket进行跟踪，一旦某个socket有事件发生，便将其保存至一个内部数组。当接到应用层调用wpoll_wait时，直接将该集合copy至epoll_event数组返回给应用层即可，不需要像select模式一样对每个sockeet进行逐一检查。 epoll_wait调用返回，所有有事件发生的连接被填入一个epoll_event数组，应用层可以根据epoll_event中的“用户自定义变量”直接映射客户端上下文（不需要借助hash表），然后处理收到的数据。 select模式的优点 &gt; select目前几乎在所有的平台上支持，其良好跨平台性是它的优点 select模式的缺点 1.select的一个缺点在于单个进程能够监控的文字描述符存在最大限制。在Linux上一般为1024个，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这一也会造成效率的降低 2.对socket的扫描是线性扫描，即采用轮询的方法，效率较低。当套接字比较多的时候，每次select（）都要遍历FD_SETSIZE个socket来完成调度，不管哪个socket是活跃的，都遍历一遍。这样会浪费很多的cpu时间，如果能给套接字注册某个回调函数，当它们活跃时，自动完成相关操作，那么就避免了轮询，这正是epll和Kqueue所做的事情。 3.维护一个用来存放大量FD的数据结构，这样会使得用户空间和内核空间在传递该结构时复制时开销大。 epoll 介绍 epoll是在2.6内核中被提出的，是之前poll和select的增强版本。但对于poll和select来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件复制到内核的一个事件表中，这样在用户空间和内核空间只需copy一次。 epoll 优点 1.没有最大并发连接的限制，能打开的FD的上限远大于1024（1G内存能监听越10万个端口） 2.效率提升，不是轮询的方式，不会随着FD数目的增加而效率下降，只有活跃用户的FD才会调用callback函数。即Epoll最大的优点在于它只管你的活跃连接，而跟连接总数无关。因而在实际的网络环境中，Epoll的效率就会远远大于select和poll 3.内存拷贝，利用mmap（）文件映射内存加速和内核的消息传递，即epoll使用mmap减少复制开销。 如何选择综上所述，在选择select，epoll时要根据具体的使用场合以及两者的自身特点： 1. 表面上看epoll的性能最好，但是在连接数少而且连接都十分活跃的情况下，select的性能可能比epoll好，毕竟epoll的通知机制需要很多的函数回调。 2. select低效是因为它每次都需要轮询。但低效是相对的，视情况也可通过良好的设计改善。 3. 一般访问量网站优先选择apahce，它稳定可靠。 4. apache的模块非常丰富，为了用它的模块得选它。 5. apache的rewirte非常强大，rewrite多就选择它。 6. 大访问量优先选择Nginx，它支持更多的并发连接 7. 处理的都是静态内容（html，图片），首先选择Nginx 8. Nginx 本质上是反向代理服务器，需要反向代理就选它。","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"php7相关","slug":"php7相关","date":"2018-10-10T16:53:37.000Z","updated":"2018-10-22T14:28:37.576Z","comments":true,"path":"2018/10/11/php7相关/","link":"","permalink":"http://yoursite.com/2018/10/11/php7相关/","excerpt":"php7相关 迭代生成器 yield迭代生成器的核心是一个yield关键字，一个生成器函数看似普通的函数，不同的是普通函数返回值，生成器返回的是可以被遍历的对象。yield和return还有不同，return会返回值并且终止函数的运行，而yield会返回一个指给循环调用此生成器函数的代码，并且只是暂停执行生成器函数。 12345678910111213141516&lt;?php function gen_one_to_three()&#123; for($i=1;$i&lt;3;$i++)&#123; //注意$i的值在不同的yield之间是保持传递的 return $i; &#125; &#125; $generator= gen_one_to_three(); var_dump($generator); echo &quot;&lt;br/&gt;&quot;; var_dump($generator instanceof Iterator);//bool(true); echo &quot;&lt;br/&gt;&quot;; foreach($generator as $val)&#123; echo &quot;&#123;$val&#125;\\n&quot;; &#125;","text":"php7相关 迭代生成器 yield迭代生成器的核心是一个yield关键字，一个生成器函数看似普通的函数，不同的是普通函数返回值，生成器返回的是可以被遍历的对象。yield和return还有不同，return会返回值并且终止函数的运行，而yield会返回一个指给循环调用此生成器函数的代码，并且只是暂停执行生成器函数。 12345678910111213141516&lt;?php function gen_one_to_three()&#123; for($i=1;$i&lt;3;$i++)&#123; //注意$i的值在不同的yield之间是保持传递的 return $i; &#125; &#125; $generator= gen_one_to_three(); var_dump($generator); echo &quot;&lt;br/&gt;&quot;; var_dump($generator instanceof Iterator);//bool(true); echo &quot;&lt;br/&gt;&quot;; foreach($generator as $val)&#123; echo &quot;&#123;$val&#125;\\n&quot;; &#125; 调用上述函数时，里面的代码并未真正的执行，而是返回了一个生成器对象，$generator = Generator object(),$generator instanceof Iterator 说明了Generator 实现了Inerator的接口，可以用foreach进行遍历，每次遍历的时候都会隐式调用current(),next(),key(),vaild()等方法(Generator类中的方法)。 Generator类中的方法 1234567891011121314151617181920Ganerator implement Iterator&#123; public mixed current (void)//返回当前产生的值 public mixed key (void)//返回当前产生的键 public mixed next (void)//生成器继续执行 public mixed rewind (void)//重置迭代器，如果迭代已经开始，这里会抛出一个异常 public mixed send (mixed $value)//向生成器中传入一个值，当前yield接受值后，继续执行下一个yield public mixed throw (Exception $exception)//向生成器抛出一个异常 public mixed vaild (void)//检查迭代器是否被关闭，已被关闭返回false，反之则true。 public mixed __wakeup (void)//序列化回调 public mixed getReturn (void)//返回generator函数的返回值，php7+&#125; 处理大数据 12345678910&lt;?php function xrange($start,$end,$step=1)&#123; for($i=$start;$i&lt;=$end,$i += $step)&#123; yield $i; &#125; &#125; foreach(xrange(1,100000000) as $value)&#123; echo &quot;&#123;$value&#125;\\n&quot;; &#125; 上面这个函数xrange()函数提供和了php内建函数range()一样的功能，但不同的是，range()返回的是一个包含所有值的数组，而xrange()依次输出的是这些值的迭代器，而不会以真正数组的形式返回。这种方法的优点显而易见，它可以让你在处理大数据集合的时候，不用一次性加载到内存当中，甚至可以处理无限大的数据流。 读取大文件在php读取大文件的时候，经常会出现内存不足的情况。如果文件过大，没法一次读完，可以使用yield来实现大文件的读取。 ``` &lt;?php //新旧方法对比 //老式读取 function readLocalFile($file){ $handle = fopen($file,&quot;r&quot;); $line = []; while(!feof($handle)){ $line[] = fgets($handle); } fclose($handle); return $line; } //新式方法 yield function readYieldFile($file){ $handle = fopen($file,&quot;r&quot;); while (! feof($handle)){ yield fgets($handle); } fclose($hanld); } //用于测试，读取内存的辅助函数 function formatBytes($btyes){ if($bytes &lt; 1024){ return $btyes .&quot;b&quot;; } else if($bytes &lt; 1048576){ return round (bytes/1024, 2) .&quot;kb&quot;; } return round (bytes/1048576, 2) .&quot;mb&quot;; } //执行 readLocalFile(&quot;./all.txt&quot;); echo formatBytes(memory_get_peak_usage()); $line = readYieldFile(&quot;./all.txt&quot;); foreach($line as $value){}; echo formatBytes(memory_get_peak_usage()); ```","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"php的代码优化","slug":"php的代码优化","date":"2018-10-10T14:00:43.000Z","updated":"2018-10-22T13:56:00.045Z","comments":true,"path":"2018/10/10/php的代码优化/","link":"","permalink":"http://yoursite.com/2018/10/10/php的代码优化/","excerpt":"","text":"php的代码小优化 if()语句的优化 123456789101112131415161718 //原始写法 if(1 ==$orderState)&#123; $status = &quot;success&quot;; &#125; else&#123; $status = &quot;failed&quot;; &#125; return $status; //简化写法 $status = &quot;failed&quot;; if( 1 == $orderState)&#123; $status = &apos;success&apos;; &#125; return $status;``` &lt;!--more --&gt;* 使用三元运算符来代替if() //原始写法 if(!empty($_POST[&apos;action&apos;])){ $action = $_POST[&apos;action&apos;]; } else{ $action = default; } //简化写法 $action = !empty($_POST[&apos;action&apos;])? $_POST[&apos;action&apos;]: default; 1* 中间结果赋值给变量 //原始写法 $str = &quot;this_is_test&quot;; $res = implode(&apos; &apos;,array_map(&apos;ucfirst&apos;,explode(&quot;_&quot;,$str))); //优化写法 $str = &quot;this_is_test&quot;; $word = explode(&quot;_&quot;,$str); $uWord = array_map(&apos;ucfirst&apos;,$word); $res = implode(&quot; &quot;, $uWord); ` 使用更加短小精悍的代码函数的最佳长度是50-150行代码，更容易理解且方便修改函数参数 不超过7个只做一件事情的函数更加利于复用","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"php的语法糖","slug":"php的语法糖","date":"2018-10-10T12:32:22.000Z","updated":"2018-10-22T13:57:50.761Z","comments":true,"path":"2018/10/10/php的语法糖/","link":"","permalink":"http://yoursite.com/2018/10/10/php的语法糖/","excerpt":"","text":"###php的语法糖 计算机语言添加的某种语言，这种语言对语言的功能并没有影响，但是方便程序员使用 常见的php语法糖 echo(),print(),die(),isset(),unset(),include(),include_once(),requice(),requice_once(),array(),list(),empty(),eval(); echo 的点号和逗好12345$foo = &quot;hello&quot;;$bar = &quot;world&quot;;echo $foo.$bor;echo $foo,$bor; 逗号优于点号 判断字符串的长度 12345678 $str= &apos;hello&apos;; if(strlen($str) === 5) echo &apos;do sth...&apos;; if(!isset($str[5]) echo &apos;do sth...&apos;;``` 优先选择第二种。strlen()函数执行速度很快，只返回在zval结构中存储的已知字符串长度，但因为它是函数，多少会有些慢.* 使用[]来代替array() $arr = array(); $arr = []; $arr = array(1,2,3,4); $arr = [1,2,3,4]; 1* 使用...来定义变长参数函数 (php7新特性) function addAll(…$sum){ $sum = array_sum($sum); return $sum; } addAll(1,2,3,4,5,6,7); 1* 不用 eval() eval(‘echo “user”;’);`eval()能够执行任何php代码，存在安全风险，非常危险. 使用suhosin保护php应用系统","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"php的良好编码","slug":"php的良好编码","date":"2018-10-10T10:00:55.000Z","updated":"2018-10-22T13:56:32.522Z","comments":true,"path":"2018/10/10/php的良好编码/","link":"","permalink":"http://yoursite.com/2018/10/10/php的良好编码/","excerpt":"php的良好编码 命名要有实含义 命名风格统一 不用拼音命名 不用语言啊关键字 适当使用注释 备份代码 坚持字符编码统一php编码–模板编码–数据库编码 变量初始化使用一个未定义的变量，比使用一个定义好的变量慢上八倍以上 使用null === 来代替 is_nullis_null 和 null === 的功能完全一样，但是后者节省了一次函数调用","text":"php的良好编码 命名要有实含义 命名风格统一 不用拼音命名 不用语言啊关键字 适当使用注释 备份代码 坚持字符编码统一php编码–模板编码–数据库编码 变量初始化使用一个未定义的变量，比使用一个定义好的变量慢上八倍以上 使用null === 来代替 is_nullis_null 和 null === 的功能完全一样，但是后者节省了一次函数调用 避免在for循环中进行计算 strtr代替str_replacestrstr的效率是str_replace的四倍 优先使用单引号$arr[‘id’]的效率是$arr[id]的七倍 如果数组下标为索引类型即键值为数字则无需注意。1，$myarray[‘key’] 单引号模式被直接解析为$myarray的值;2，$myarray[“key”]双引号模式会首先分析”key”字符串内部是否包含 PHP变量，然后再解析为$myarray的值;3，$myarray[key]没有任何引号会先分析局部作用域内有没有key常量定义(即有无define(‘key’,’val’))，如果有则使用局部key常量代表的常量值作为数组键值;否则继续分析全局作用域内有没有key常量定义，如果有则使用全局key常量代表的常量值作为数组键值;否则内部转换key为’key’字符串标量值并抛出E_NOTICE异常。二、$myarray[“$str_key”] 与 $myarray[$str_key]的差别此方式亦为通过字符串类型数组下标访问数组的值，如果数组下标为索引类型即数字则无需注意。其实这里无需额外添加双引号以表示$str_key变量代表的是字符串值，即$myarray[“$str_key”] === $myarray[$str_key] header编码 header(“content_type: text/html;charset=utf-8”); 不要写php的结束标志纯php代码，最好删除文件末尾的php结束标志 测试环境开启所有错误 error_reporting(7)开始所有错误 error_reporting(0)关闭所有错误 1: E_ERROR2: E_WARNING3: E_PARSE切记，上线之后要关闭报错，将错误代码写入日志中，方便查错 屏蔽错误非常低效尽量不用@ 用false表示错误，用null标志不存在对于操作类的函数，失败时返回flase，表示操作失败了。对于查询类的函数，则应该返回null，来表示查询不到。 优先使用php内置函数正则耗时，应该尽量避免，采用直接的字符串处理函数，如 filter_var(&#39;tanghuo@163.com‘,FILTER_VALIDATE_EMAIL); parse_url 解析URL ，返回其组成部分 http_build_query 生成一个URL-encodde之后的请求字符串 exif_imagetype 判断一个图像的类型 uniqid 生成一个唯一的ID get_browser 获取浏览器具有的功能 尽量熟悉php手册中的字符串函数和数组函数 防御式编程思想不相信外部的一切输入，所有的输入都要检查 12&lt;?php $username=htmlspecialchars($_GET[&quot;username&quot;]); 使用PDO操控mysql","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"session，GC垃圾回收机制","slug":"session，GC垃圾回收机制","date":"2018-10-09T17:49:17.000Z","updated":"2018-10-10T03:24:39.046Z","comments":true,"path":"2018/10/10/session，GC垃圾回收机制/","link":"","permalink":"http://yoursite.com/2018/10/10/session，GC垃圾回收机制/","excerpt":"何为session session类同于更加安全的cookie，解决http协议无状态的问题，实现保持会话，跨站登录等。其数据存放在服务器端。在客户端仅存放用于对接认证的sessionID。 GC垃圾回收机制 若没有变量指向对象，则视为垃圾。php将执行GC垃圾处理机制，进行清理，防止内存溢出。 GC的启动率越高，系统的性能越低. session_gc_probability 等于分子，session_gc_divisor为分母，如前者为1，后者为100，则在启动session_start()时，有百分之一的几率启动gc(garbage collection)进程,根据session.gc_maxlifetime 对逾期的session进行回收处理.(就是扫描所有的session信息，用当前时间减去session的最后修改时间（modified date），同session.gc_maxlifetime参数进行比较，如果生存时间已经超过gc_maxlifetime，就把该session删除)","text":"何为session session类同于更加安全的cookie，解决http协议无状态的问题，实现保持会话，跨站登录等。其数据存放在服务器端。在客户端仅存放用于对接认证的sessionID。 GC垃圾回收机制 若没有变量指向对象，则视为垃圾。php将执行GC垃圾处理机制，进行清理，防止内存溢出。 GC的启动率越高，系统的性能越低. session_gc_probability 等于分子，session_gc_divisor为分母，如前者为1，后者为100，则在启动session_start()时，有百分之一的几率启动gc(garbage collection)进程,根据session.gc_maxlifetime 对逾期的session进行回收处理.(就是扫描所有的session信息，用当前时间减去session的最后修改时间（modified date），同session.gc_maxlifetime参数进行比较，如果生存时间已经超过gc_maxlifetime，就把该session删除) ..session.save_handler = files默认为file，定义session在服务端的保存方式，file意为把sesion保存到一个临时文件里，如果我们想自定义别的方式保存（比如用数据库），则需要把该项设置为user； ..一个已知管用的方法是，使用session_set_save_handler，接管所有的session管理工作，一般是把session信息存储到数据库，这样可以通过SQL语句来删除所有过期的session，精确地控制session的有效期。这也是基于PHP的大型网站常用的方法。但是，一般的小型网站，似乎没有必要这么劳师动众 session在php5配置文件中的参数说明 ;处理session存取的模式（预设：files）session.save_handler = files ;session档案存放路径（预设：/tmp）session.save_path = /tmp ;session使用cookie的功能（预设：启动 1）session.use_cookies = 1 ;session的名字（预设：PHPSESSID）session.name = PHPSESSID ;自动启动（预设：关 0，此处可以改为1）session.auto_start = 0 ;session使用cookie的生存期，以秒为单位（预设：随浏览器关闭而消失 0）session.cookie_lifetime = 0 ;session使用cookie的路径（预设：与domian相同或根路径 /）session.cookie_path = / ;session使用cookie的域名称（预设：空）session.cookie_domain = ;处理连续资料的方式，本功能只有WDDX模组或PHP内部使用（预设：php）session.serialize_handler = php ;按千分之一的比率进行垃圾收集 ;垃圾收集的处理几率（预设：1） session.gc_probability = 1 ;设置进程比率，（php5新增参数，预设：1000） session.gc_divisor = 1000 ;（垃圾收集）被处理前的生存期（预设：1440[秒]） session.gc_maxlifetime = 1440 ;PHP 4.2和以前的版本都有个BUG,即使你禁止了”允许注册全局变量”.仍然可以让你在全局变量范围中初始化一个SESSION的值 ;PHP 4.3 和以后的版本会发出相应的警告,你可以禁止警告.PHP5中,只有你打开了bug_compat_42(=ON),警告才会显示. session.bug_compat_42，0 session.bug_compat_warn = 1 ;session在重新整理时检查session是否还存在（预设：空） session.referer_check = ;特别设定session值的长度（预设：关） session.entropy_length = 0 ;特别设定session值的文件 session.entropy_file = ;使用cache限制器（预设：不要cache） session.cache_limiter = nocache ;使用cache的生存期 session.cache_expire = 180 ;使用sid值（session_id）传送模式（基于安全，预设：关） session.use_trans_sid = 0 ;选择一个HASH函数,0为MD5(128比特强度),1为SHA-1(160比特强度) session.hash_function = 0 ;定义当转换2进制hash数据为一些可读的数据时,每个字符存储多少个比特. ;4 比特: 0-9, a-f ;5 比特: 0-9, a-v ;6 比特: 0-9, a-z, A-Z, “-”, “,” session.hash_bits_per_character = 5 ;URL重指向的标签 url_rewriter.tags = “a=href,area=href,frame=src,input=src,form=fakeentry” 参考文章: 关于session在PHP5的配置文件中的详细设置参数说明 https://www.jb51.net/article/26891.htm session垃圾回收机制 https://www.cnblogs.com/wenphp/p/4871500.html 未读陈列 深度解析 Session 机制 https://www.jianshu.com/p/e8141bd63990","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"汇总","slug":"汇总","date":"2018-10-09T17:09:53.000Z","updated":"2018-10-18T15:36:11.966Z","comments":true,"path":"2018/10/10/汇总/","link":"","permalink":"http://yoursite.com/2018/10/10/汇总/","excerpt":"","text":"汇总此处用作汇总，陈列网络上看到的有益东西: php PHP declare(ticks=N); 的作用 https://www.cnblogs.com/loveyouyou616/p/5799933.html makedown的使用 makedown的基本常用编写语法 https://www.cnblogs.com/liugang-vip/p/6337580.html 较为全面的语法介绍 https://www.jianshu.com/p/b03a8d7b1719 hexo相关 所用主体的github主页https://github.com/litten/hexo-theme-yilia 搭建用hexo+github搭建个人博客的基础教程http://blog.haoji.me/build-blog-website-by-hexo-github.html#da-jian-github-bo-kehexo g hexo d 以及https://www.jianshu.com/p/21d80d5bfca1 命名空间相关 PHP命名空间(Namespace)的使用详解 https://www.cnblogs.com/kuyuecs/p/3556421.html redis Redis 命令参考 http://redisdoc.com memcache 【Memcache】常见问题总结 深入 https://blog.csdn.net/qq_28602957/article/details/72677429 memcache 和 memcached 的区别分析 https://blog.csdn.net/baidu_30000217/article/details/53586536 PHP扩展模块memcached长连接使用方法分析 https://www.jb51.net/article/58918.htm 软件相关 atom的部分基础快捷键https://blog.csdn.net/u010924692/article/details/78245850 工具相关 composer 在windows下的安装https://blog.csdn.net/csdn_dengfan/article/details/54912039 工具网页 packagist the PHP package Repositoryhttps://packagist.org","categories":[],"tags":[]}]}